{"version":3,"file":"188.0755ccf7404a78b58243.js","mappings":"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","sources":["webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/types.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs"],"sourcesContent":["import { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction addBits(srcParts, parts, name) {\n  if (srcParts) {\n    for (const i in srcParts) {\n      const id = i.toLocaleLowerCase();\n      const part = parts[id];\n      if (part) {\n        let sanitisedPart = srcParts[i];\n        if (i === \"header\") {\n          sanitisedPart = sanitisedPart.replace(/@in\\s+[^;]+;\\s*/g, \"\").replace(/@out\\s+[^;]+;\\s*/g, \"\");\n        }\n        if (name) {\n          part.push(`//----${name}----//`);\n        }\n        part.push(sanitisedPart);\n      } else {\n        warn(`${i} placement hook does not exist in shader`);\n      }\n    }\n  }\n}\n\nexport { addBits };\n//# sourceMappingURL=addBits.mjs.map\n","\"use strict\";\nconst findHooksRx = /\\{\\{(.*?)\\}\\}/g;\nfunction compileHooks(programSrc) {\n  const parts = {};\n  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, \"\")) ?? [];\n  partMatches.forEach((hook) => {\n    parts[hook] = [];\n  });\n  return parts;\n}\n\nexport { compileHooks, findHooksRx };\n//# sourceMappingURL=compileHooks.mjs.map\n","\"use strict\";\nfunction extractInputs(fragmentSource, out) {\n  let match;\n  const regex = /@in\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction compileInputs(fragments, template, sort = false) {\n  const results = [];\n  extractInputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractInputs(fragment.header, results);\n    }\n  });\n  const mainInput = results;\n  if (sort) {\n    mainInput.sort();\n  }\n  const finalString = mainInput.map((inValue, i) => `       @location(${i}) ${inValue},`).join(\"\\n\");\n  let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, \"\");\n  cleanedString = cleanedString.replace(\"{{in}}\", `\n${finalString}\n`);\n  return cleanedString;\n}\n\nexport { compileInputs };\n//# sourceMappingURL=compileInputs.mjs.map\n","\"use strict\";\nfunction extractOutputs(fragmentSource, out) {\n  let match;\n  const regex = /@out\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction extractVariableName(value) {\n  const regex = /\\b(\\w+)\\s*:/g;\n  const match = regex.exec(value);\n  return match ? match[1] : \"\";\n}\nfunction stripVariable(value) {\n  const regex = /@.*?\\s+/g;\n  return value.replace(regex, \"\");\n}\nfunction compileOutputs(fragments, template) {\n  const results = [];\n  extractOutputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractOutputs(fragment.header, results);\n    }\n  });\n  let index = 0;\n  const mainStruct = results.sort().map((inValue) => {\n    if (inValue.indexOf(\"builtin\") > -1) {\n      return inValue;\n    }\n    return `@location(${index++}) ${inValue}`;\n  }).join(\",\\n\");\n  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join(\"\\n\");\n  const mainEnd = `return VSOutput(\n                ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(\",\\n\")});`;\n  let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, \"\");\n  compiledCode = compiledCode.replace(\"{{struct}}\", `\n${mainStruct}\n`);\n  compiledCode = compiledCode.replace(\"{{start}}\", `\n${mainStart}\n`);\n  compiledCode = compiledCode.replace(\"{{return}}\", `\n${mainEnd}\n`);\n  return compiledCode;\n}\n\nexport { compileOutputs };\n//# sourceMappingURL=compileOutputs.mjs.map\n","\"use strict\";\nfunction injectBits(templateSrc, fragmentParts) {\n  let out = templateSrc;\n  for (const i in fragmentParts) {\n    const parts = fragmentParts[i];\n    const toInject = parts.join(\"\\n\");\n    if (toInject.length) {\n      out = out.replace(`{{${i}}}`, `//-----${i} START-----//\n${parts.join(\"\\n\")}\n//----${i} FINISH----//`);\n    } else {\n      out = out.replace(`{{${i}}}`, \"\");\n    }\n  }\n  return out;\n}\n\nexport { injectBits };\n//# sourceMappingURL=injectBits.mjs.map\n","import { addBits } from './utils/addBits.mjs';\nimport { compileHooks } from './utils/compileHooks.mjs';\nimport { compileInputs } from './utils/compileInputs.mjs';\nimport { compileOutputs } from './utils/compileOutputs.mjs';\nimport { injectBits } from './utils/injectBits.mjs';\n\n\"use strict\";\nconst cacheMap = /* @__PURE__ */ Object.create(null);\nconst bitCacheMap = /* @__PURE__ */ new Map();\nlet CACHE_UID = 0;\nfunction compileHighShader({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n  cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileHighShaderGl({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileInputsAndOutputs(template, bits) {\n  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n  compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n  return {\n    vertex: compiledVertex,\n    fragment: compiledFragment\n  };\n}\nfunction generateCacheId(template, bits) {\n  return bits.map((highFragment) => {\n    if (!bitCacheMap.has(highFragment)) {\n      bitCacheMap.set(highFragment, CACHE_UID++);\n    }\n    return bitCacheMap.get(highFragment);\n  }).sort((a, b) => a - b).join(\"-\") + template.vertex + template.fragment;\n}\nfunction compileBits(vertex, fragment, bits) {\n  const vertexParts = compileHooks(vertex);\n  const fragmentParts = compileHooks(fragment);\n  bits.forEach((shaderBit) => {\n    addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n  });\n  return {\n    vertex: injectBits(vertex, vertexParts),\n    fragment: injectBits(fragment, fragmentParts)\n  };\n}\n\nexport { compileHighShader, compileHighShaderGl };\n//# sourceMappingURL=compileHighShader.mjs.map\n","\"use strict\";\nconst vertexGPUTemplate = (\n  /* wgsl */\n  `\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`\n);\nconst fragmentGPUTemplate = (\n  /* wgsl */\n  `\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n`\n);\nconst vertexGlTemplate = (\n  /* glsl */\n  `\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`\n);\nconst fragmentGlTemplate = (\n  /* glsl */\n  `\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n`\n);\n\nexport { fragmentGPUTemplate, fragmentGlTemplate, vertexGPUTemplate, vertexGlTemplate };\n//# sourceMappingURL=defaultProgramTemplate.mjs.map\n","\"use strict\";\nconst globalUniformsBit = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    )\n  }\n};\nconst globalUniformsUBOBitGl = {\n  name: \"global-uniforms-ubo-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    )\n  }\n};\nconst globalUniformsBitGl = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    )\n  }\n};\n\nexport { globalUniformsBit, globalUniformsBitGl, globalUniformsUBOBitGl };\n//# sourceMappingURL=globalUniformsBit.mjs.map\n","import { GlProgram } from '../renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram.mjs';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader.mjs';\nimport { fragmentGPUTemplate, vertexGPUTemplate, vertexGlTemplate, fragmentGlTemplate } from './defaultProgramTemplate.mjs';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit.mjs';\n\n\"use strict\";\nfunction compileHighShaderGpuProgram({ bits, name }) {\n  const source = compileHighShader({\n    template: {\n      fragment: fragmentGPUTemplate,\n      vertex: vertexGPUTemplate\n    },\n    bits: [\n      globalUniformsBit,\n      ...bits\n    ]\n  });\n  return GpuProgram.from({\n    name,\n    vertex: {\n      source: source.vertex,\n      entryPoint: \"main\"\n    },\n    fragment: {\n      source: source.fragment,\n      entryPoint: \"main\"\n    }\n  });\n}\nfunction compileHighShaderGlProgram({ bits, name }) {\n  return new GlProgram({\n    name,\n    ...compileHighShaderGl({\n      template: {\n        vertex: vertexGlTemplate,\n        fragment: fragmentGlTemplate\n      },\n      bits: [\n        globalUniformsBitGl,\n        ...bits\n      ]\n    })\n  });\n}\n\nexport { compileHighShaderGlProgram, compileHighShaderGpuProgram };\n//# sourceMappingURL=compileHighShaderToProgram.mjs.map\n","\"use strict\";\nconst colorBit = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            @in aColor: vec4<f32>;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\nconst colorBitGl = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            in vec4 aColor;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\n\nexport { colorBit, colorBitGl };\n//# sourceMappingURL=colorBit.mjs.map\n","import { maxRecommendedTextures } from '../../renderers/shared/texture/utils/maxRecommendedTextures.mjs';\n\n\"use strict\";\nconst textureBatchBitGpuCache = {};\nfunction generateBindingSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n    src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n  } else {\n    let bindingIndex = 0;\n    for (let i = 0; i < maxTextures; i++) {\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n    }\n  }\n  return src.join(\"\\n\");\n}\nfunction generateSampleSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n  } else {\n    src.push(\"switch vTextureId {\");\n    for (let i = 0; i < maxTextures; i++) {\n      if (i === maxTextures - 1) {\n        src.push(`  default:{`);\n      } else {\n        src.push(`  case ${i}:{`);\n      }\n      src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n      src.push(`      break;}`);\n    }\n    src.push(`}`);\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBit(maxTextures) {\n  if (!textureBatchBitGpuCache[maxTextures]) {\n    textureBatchBitGpuCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${generateBindingSrc(maxRecommendedTextures())}\n            `,\n        main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${generateSampleSrc(maxRecommendedTextures())}\n            `\n      }\n    };\n  }\n  return textureBatchBitGpuCache[maxTextures];\n}\nconst textureBatchBitGlCache = {};\nfunction generateSampleGlSrc(maxTextures) {\n  const src = [];\n  for (let i = 0; i < maxTextures; i++) {\n    if (i > 0) {\n      src.push(\"else\");\n    }\n    if (i < maxTextures - 1) {\n      src.push(`if(vTextureId < ${i}.5)`);\n    }\n    src.push(\"{\");\n    src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n    src.push(\"}\");\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBitGl(maxTextures) {\n  if (!textureBatchBitGlCache[maxTextures]) {\n    textureBatchBitGlCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${maxTextures}];\n              \n            `,\n        main: `\n    \n                ${generateSampleGlSrc(maxRecommendedTextures())}\n            `\n      }\n    };\n  }\n  return textureBatchBitGlCache[maxTextures];\n}\n\nexport { generateTextureBatchBit, generateTextureBatchBitGl };\n//# sourceMappingURL=generateTextureBatchBit.mjs.map\n","\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n//# sourceMappingURL=localUniformBit.mjs.map\n","\"use strict\";\nconst roundPixelsBit = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\nconst roundPixelsBitGl = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\n\nexport { roundPixelsBit, roundPixelsBitGl };\n//# sourceMappingURL=roundPixelsBit.mjs.map\n","import { getTestContext } from './getTestContext.mjs';\n\n\"use strict\";\nlet maxFragmentPrecision;\nfunction getMaxFragmentPrecision() {\n  if (!maxFragmentPrecision) {\n    maxFragmentPrecision = \"mediump\";\n    const gl = getTestContext();\n    if (gl) {\n      if (gl.getShaderPrecisionFormat) {\n        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n        maxFragmentPrecision = shaderFragment.precision ? \"highp\" : \"mediump\";\n      }\n    }\n  }\n  return maxFragmentPrecision;\n}\n\nexport { getMaxFragmentPrecision };\n//# sourceMappingURL=getMaxFragmentPrecision.mjs.map\n","\"use strict\";\nconst fragmentNameCache = {};\nconst VertexNameCache = {};\nfunction setProgramName(src, { name = `pixi-program` }, isFragment = true) {\n  name = name.replace(/\\s+/g, \"-\");\n  name += isFragment ? \"-fragment\" : \"-vertex\";\n  const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n  if (nameCache[name]) {\n    nameCache[name]++;\n    name += `-${nameCache[name]}`;\n  } else {\n    nameCache[name] = 1;\n  }\n  if (src.indexOf(\"#define SHADER_NAME\") !== -1)\n    return src;\n  const shaderName = `#define SHADER_NAME ${name}`;\n  return `${shaderName}\n${src}`;\n}\n\nexport { setProgramName };\n//# sourceMappingURL=setProgramName.mjs.map\n","import { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision.mjs';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines.mjs';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision.mjs';\nimport { insertVersion } from './program/preprocessors/insertVersion.mjs';\nimport { setProgramName } from './program/preprocessors/setProgramName.mjs';\nimport { stripVersion } from './program/preprocessors/stripVersion.mjs';\n\n\"use strict\";\nconst processes = {\n  // strips any version headers..\n  stripVersion,\n  // adds precision string if not already present\n  ensurePrecision,\n  // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n  addProgramDefines,\n  // add the program name to the shader\n  setProgramName,\n  // add the version string to the shader header\n  insertVersion\n};\nconst programCache = /* @__PURE__ */ Object.create(null);\nconst _GlProgram = class _GlProgram {\n  /**\n   * Creates a shiny new GlProgram. Used by WebGL renderer.\n   * @param options - The options for the program.\n   */\n  constructor(options) {\n    options = { ..._GlProgram.defaultOptions, ...options };\n    const isES300 = options.fragment.indexOf(\"#version 300 es\") !== -1;\n    const preprocessorOptions = {\n      stripVersion: isES300,\n      ensurePrecision: {\n        requestedFragmentPrecision: options.preferredFragmentPrecision,\n        requestedVertexPrecision: options.preferredVertexPrecision,\n        maxSupportedVertexPrecision: \"highp\",\n        maxSupportedFragmentPrecision: getMaxFragmentPrecision()\n      },\n      setProgramName: {\n        name: options.name\n      },\n      addProgramDefines: isES300,\n      insertVersion: isES300\n    };\n    let fragment = options.fragment;\n    let vertex = options.vertex;\n    Object.keys(processes).forEach((processKey) => {\n      const processOptions = preprocessorOptions[processKey];\n      fragment = processes[processKey](fragment, processOptions, true);\n      vertex = processes[processKey](vertex, processOptions, false);\n    });\n    this.fragment = fragment;\n    this.vertex = vertex;\n    this._key = createIdFromString(`${this.vertex}:${this.fragment}`, \"gl-program\");\n  }\n  /** destroys the program */\n  destroy() {\n    this.fragment = null;\n    this.vertex = null;\n    this._attributeData = null;\n    this._uniformData = null;\n    this._uniformBlockData = null;\n    this.transformFeedbackVaryings = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex}:${options.fragment}`;\n    if (!programCache[key]) {\n      programCache[key] = new _GlProgram(options);\n    }\n    return programCache[key];\n  }\n};\n/** The default options used by the program. */\n_GlProgram.defaultOptions = {\n  preferredVertexPrecision: \"highp\",\n  preferredFragmentPrecision: \"mediump\"\n};\nlet GlProgram = _GlProgram;\n\nexport { GlProgram };\n//# sourceMappingURL=GlProgram.mjs.map\n","\"use strict\";\nfunction stripVersion(src, isES300) {\n  if (!isES300)\n    return src;\n  return src.replace(\"#version 300 es\", \"\");\n}\n\nexport { stripVersion };\n//# sourceMappingURL=stripVersion.mjs.map\n","\"use strict\";\nfunction ensurePrecision(src, options, isFragment) {\n  const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n  if (src.substring(0, 9) !== \"precision\") {\n    let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n    if (precision === \"highp\" && maxSupportedPrecision !== \"highp\") {\n      precision = \"mediump\";\n    }\n    return `precision ${precision} float;\n${src}`;\n  } else if (maxSupportedPrecision !== \"highp\" && src.substring(0, 15) === \"precision highp\") {\n    return src.replace(\"precision highp\", \"precision mediump\");\n  }\n  return src;\n}\n\nexport { ensurePrecision };\n//# sourceMappingURL=ensurePrecision.mjs.map\n","\"use strict\";\nfunction addProgramDefines(src, isES300, isFragment) {\n  if (isES300)\n    return src;\n  if (isFragment) {\n    src = src.replace(\"out vec4 finalColor;\", \"\");\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n  }\n  return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n\nexport { addProgramDefines };\n//# sourceMappingURL=addProgramDefines.mjs.map\n","\"use strict\";\nfunction insertVersion(src, isES300) {\n  if (!isES300)\n    return src;\n  return `#version 300 es\n${src}`;\n}\n\nexport { insertVersion };\n//# sourceMappingURL=insertVersion.mjs.map\n","import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nconst WGSL_TO_VERTEX_TYPES = {\n  f32: \"float32\",\n  \"vec2<f32>\": \"float32x2\",\n  \"vec3<f32>\": \"float32x3\",\n  \"vec4<f32>\": \"float32x4\",\n  vec2f: \"float32x2\",\n  vec3f: \"float32x3\",\n  vec4f: \"float32x4\",\n  i32: \"sint32\",\n  \"vec2<i32>\": \"sint32x2\",\n  \"vec3<i32>\": \"sint32x3\",\n  \"vec4<i32>\": \"sint32x4\",\n  u32: \"uint32\",\n  \"vec2<u32>\": \"uint32x2\",\n  \"vec3<u32>\": \"uint32x3\",\n  \"vec4<u32>\": \"uint32x4\",\n  bool: \"uint32\",\n  \"vec2<bool>\": \"uint32x2\",\n  \"vec3<bool>\": \"uint32x3\",\n  \"vec4<bool>\": \"uint32x4\"\n};\nfunction extractAttributesFromGpuProgram({ source, entryPoint }) {\n  const results = {};\n  const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n  if (mainVertStart !== -1) {\n    const arrowFunctionStart = source.indexOf(\"->\", mainVertStart);\n    if (arrowFunctionStart !== -1) {\n      const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n      const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n      let match;\n      while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {\n        const format = WGSL_TO_VERTEX_TYPES[match[3]] ?? \"float32\";\n        results[match[2]] = {\n          location: parseInt(match[1], 10),\n          format,\n          stride: getAttributeInfoFromFormat(format).stride,\n          offset: 0,\n          instance: false,\n          start: 0\n        };\n      }\n    }\n  }\n  return results;\n}\n\nexport { extractAttributesFromGpuProgram };\n//# sourceMappingURL=extractAttributesFromGpuProgram.mjs.map\n","\"use strict\";\nfunction extractStructAndGroups(wgsl) {\n  const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n  const groupPattern = /@group\\((\\d+)\\)/;\n  const bindingPattern = /@binding\\((\\d+)\\)/;\n  const namePattern = /var(<[^>]+>)? (\\w+)/;\n  const typePattern = /:\\s*(\\w+)/;\n  const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n  const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n  const structName = /struct\\s+(\\w+)/;\n  const groups = wgsl.match(linePattern)?.map((item) => ({\n    group: parseInt(item.match(groupPattern)[1], 10),\n    binding: parseInt(item.match(bindingPattern)[1], 10),\n    name: item.match(namePattern)[2],\n    isUniform: item.match(namePattern)[1] === \"<uniform>\",\n    type: item.match(typePattern)[1]\n  }));\n  if (!groups) {\n    return {\n      groups: [],\n      structs: []\n    };\n  }\n  const structs = wgsl.match(structPattern)?.map((struct) => {\n    const name = struct.match(structName)[1];\n    const members = struct.match(structMemberPattern).reduce((acc, member) => {\n      const [name2, type] = member.split(\":\");\n      acc[name2.trim()] = type.trim();\n      return acc;\n    }, {});\n    if (!members) {\n      return null;\n    }\n    return { name, members };\n  }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n  return {\n    groups,\n    structs\n  };\n}\n\nexport { extractStructAndGroups };\n//# sourceMappingURL=extractStructAndGroups.mjs.map\n","\"use strict\";\nvar ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {\n  ShaderStage2[ShaderStage2[\"VERTEX\"] = 1] = \"VERTEX\";\n  ShaderStage2[ShaderStage2[\"FRAGMENT\"] = 2] = \"FRAGMENT\";\n  ShaderStage2[ShaderStage2[\"COMPUTE\"] = 4] = \"COMPUTE\";\n  return ShaderStage2;\n})(ShaderStage || {});\n\nexport { ShaderStage };\n//# sourceMappingURL=const.mjs.map\n","import { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram.mjs';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups.mjs';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups.mjs';\nimport { generateLayoutHash } from './utils/generateLayoutHash.mjs';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates.mjs';\n\n\"use strict\";\nconst programCache = /* @__PURE__ */ Object.create(null);\nclass GpuProgram {\n  /**\n   * Create a new GpuProgram\n   * @param options - The options for the gpu program\n   */\n  constructor(options) {\n    /**\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    const { fragment, vertex, layout, gpuLayout, name } = options;\n    this.name = name;\n    this.fragment = fragment;\n    this.vertex = vertex;\n    if (fragment.source === vertex.source) {\n      const structsAndGroups = extractStructAndGroups(fragment.source);\n      this.structsAndGroups = structsAndGroups;\n    } else {\n      const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n      const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n      this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n    }\n    this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n    this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n    this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);\n    this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);\n    this._generateProgramKey();\n  }\n  // TODO maker this pure\n  _generateProgramKey() {\n    const { vertex, fragment } = this;\n    const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n    this._layoutKey = createIdFromString(bigKey, \"program\");\n  }\n  get attributeData() {\n    this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));\n    return this._attributeData;\n  }\n  /** destroys the program */\n  destroy() {\n    this.gpuLayout = null;\n    this.layout = null;\n    this.structsAndGroups = null;\n    this.fragment = null;\n    this.vertex = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n    if (!programCache[key]) {\n      programCache[key] = new GpuProgram(options);\n    }\n    return programCache[key];\n  }\n}\n\nexport { GpuProgram };\n//# sourceMappingURL=GpuProgram.mjs.map\n","\"use strict\";\nfunction removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {\n  const structNameSet = /* @__PURE__ */ new Set();\n  const dupeGroupKeySet = /* @__PURE__ */ new Set();\n  const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {\n    if (structNameSet.has(struct.name)) {\n      return false;\n    }\n    structNameSet.add(struct.name);\n    return true;\n  });\n  const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {\n    const key = `${group.name}-${group.binding}`;\n    if (dupeGroupKeySet.has(key)) {\n      return false;\n    }\n    dupeGroupKeySet.add(key);\n    return true;\n  });\n  return { structs, groups };\n}\n\nexport { removeStructAndGroupDuplicates };\n//# sourceMappingURL=removeStructAndGroupDuplicates.mjs.map\n","\"use strict\";\nfunction generateLayoutHash({ groups }) {\n  const layout = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (!layout[group.group]) {\n      layout[group.group] = {};\n    }\n    layout[group.group][group.name] = group.binding;\n  }\n  return layout;\n}\n\nexport { generateLayoutHash };\n//# sourceMappingURL=generateLayoutHash.mjs.map\n","import { ShaderStage } from '../../../shared/shader/const.mjs';\n\n\"use strict\";\nfunction generateGpuLayoutGroups({ groups }) {\n  const layout = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (!layout[group.group]) {\n      layout[group.group] = [];\n    }\n    if (group.isUniform) {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n        buffer: {\n          type: \"uniform\"\n        }\n      });\n    } else if (group.type === \"sampler\") {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.FRAGMENT,\n        sampler: {\n          type: \"filtering\"\n        }\n      });\n    } else if (group.type === \"texture_2d\") {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.FRAGMENT,\n        texture: {\n          sampleType: \"float\",\n          viewDimension: \"2d\",\n          multisampled: false\n        }\n      });\n    }\n  }\n  return layout;\n}\n\nexport { generateGpuLayoutGroups };\n//# sourceMappingURL=generateGpuLayoutGroups.mjs.map\n","\"use strict\";\nconst attributeFormatData = {\n  uint8x2: { size: 2, stride: 2, normalised: false },\n  uint8x4: { size: 4, stride: 4, normalised: false },\n  sint8x2: { size: 2, stride: 2, normalised: false },\n  sint8x4: { size: 4, stride: 4, normalised: false },\n  unorm8x2: { size: 2, stride: 2, normalised: true },\n  unorm8x4: { size: 4, stride: 4, normalised: true },\n  snorm8x2: { size: 2, stride: 2, normalised: true },\n  snorm8x4: { size: 4, stride: 4, normalised: true },\n  uint16x2: { size: 2, stride: 4, normalised: false },\n  uint16x4: { size: 4, stride: 8, normalised: false },\n  sint16x2: { size: 2, stride: 4, normalised: false },\n  sint16x4: { size: 4, stride: 8, normalised: false },\n  unorm16x2: { size: 2, stride: 4, normalised: true },\n  unorm16x4: { size: 4, stride: 8, normalised: true },\n  snorm16x2: { size: 2, stride: 4, normalised: true },\n  snorm16x4: { size: 4, stride: 8, normalised: true },\n  float16x2: { size: 2, stride: 4, normalised: false },\n  float16x4: { size: 4, stride: 8, normalised: false },\n  float32: { size: 1, stride: 4, normalised: false },\n  float32x2: { size: 2, stride: 8, normalised: false },\n  float32x3: { size: 3, stride: 12, normalised: false },\n  float32x4: { size: 4, stride: 16, normalised: false },\n  uint32: { size: 1, stride: 4, normalised: false },\n  uint32x2: { size: 2, stride: 8, normalised: false },\n  uint32x3: { size: 3, stride: 12, normalised: false },\n  uint32x4: { size: 4, stride: 16, normalised: false },\n  sint32: { size: 1, stride: 4, normalised: false },\n  sint32x2: { size: 2, stride: 8, normalised: false },\n  sint32x3: { size: 3, stride: 12, normalised: false },\n  sint32x4: { size: 4, stride: 16, normalised: false }\n};\nfunction getAttributeInfoFromFormat(format) {\n  return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n\nexport { getAttributeInfoFromFormat };\n//# sourceMappingURL=getAttributeInfoFromFormat.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { GlProgram } from '../../gl/shader/GlProgram.mjs';\nimport { BindGroup } from '../../gpu/shader/BindGroup.mjs';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram.mjs';\nimport { RendererType } from '../../types.mjs';\nimport { UniformGroup } from './UniformGroup.mjs';\n\n\"use strict\";\nclass Shader extends EventEmitter {\n  constructor(options) {\n    super();\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    this._uniformBindMap = /* @__PURE__ */ Object.create(null);\n    this._ownedBindGroups = [];\n    let {\n      gpuProgram,\n      glProgram,\n      groups,\n      resources,\n      compatibleRenderers,\n      groupMap\n    } = options;\n    this.gpuProgram = gpuProgram;\n    this.glProgram = glProgram;\n    if (compatibleRenderers === void 0) {\n      compatibleRenderers = 0;\n      if (gpuProgram)\n        compatibleRenderers |= RendererType.WEBGPU;\n      if (glProgram)\n        compatibleRenderers |= RendererType.WEBGL;\n    }\n    this.compatibleRenderers = compatibleRenderers;\n    const nameHash = {};\n    if (!resources && !groups) {\n      resources = {};\n    }\n    if (resources && groups) {\n      throw new Error(\"[Shader] Cannot have both resources and groups\");\n    } else if (!gpuProgram && groups && !groupMap) {\n      throw new Error(\"[Shader] No group map or WebGPU shader provided - consider using resources instead.\");\n    } else if (!gpuProgram && groups && groupMap) {\n      for (const i in groupMap) {\n        for (const j in groupMap[i]) {\n          const uniformName = groupMap[i][j];\n          nameHash[uniformName] = {\n            group: i,\n            binding: j,\n            name: uniformName\n          };\n        }\n      }\n    } else if (gpuProgram && groups && !groupMap) {\n      const groupData = gpuProgram.structsAndGroups.groups;\n      groupMap = {};\n      groupData.forEach((data) => {\n        groupMap[data.group] = groupMap[data.group] || {};\n        groupMap[data.group][data.binding] = data.name;\n        nameHash[data.name] = data;\n      });\n    } else if (resources) {\n      if (!gpuProgram) {\n        groupMap = {};\n        groups = {\n          99: new BindGroup()\n        };\n        this._ownedBindGroups.push(groups[99]);\n        let bindTick = 0;\n        for (const i in resources) {\n          nameHash[i] = { group: 99, binding: bindTick, name: i };\n          groupMap[99] = groupMap[99] || {};\n          groupMap[99][bindTick] = i;\n          bindTick++;\n        }\n      } else {\n        const groupData = gpuProgram.structsAndGroups.groups;\n        groupMap = {};\n        groupData.forEach((data) => {\n          groupMap[data.group] = groupMap[data.group] || {};\n          groupMap[data.group][data.binding] = data.name;\n          nameHash[data.name] = data;\n        });\n      }\n      groups = {};\n      for (const i in resources) {\n        const name = i;\n        let value = resources[i];\n        if (!value.source && !value._resourceType) {\n          value = new UniformGroup(value);\n        }\n        const data = nameHash[name];\n        if (data) {\n          if (!groups[data.group]) {\n            groups[data.group] = new BindGroup();\n            this._ownedBindGroups.push(groups[data.group]);\n          }\n          groups[data.group].setResource(value, data.binding);\n        }\n      }\n    }\n    this.groups = groups;\n    this._uniformBindMap = groupMap;\n    this.resources = this._buildResourceAccessor(groups, nameHash);\n  }\n  /**\n   * Sometimes a resource group will be provided later (for example global uniforms)\n   * In such cases, this method can be used to let the shader know about the group.\n   * @param name - the name of the resource group\n   * @param groupIndex - the index of the group (should match the webGPU shader group location)\n   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n   */\n  addResource(name, groupIndex, bindIndex) {\n    var _a, _b;\n    (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});\n    (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);\n    if (!this.groups[groupIndex]) {\n      this.groups[groupIndex] = new BindGroup();\n      this._ownedBindGroups.push(this.groups[groupIndex]);\n    }\n  }\n  _buildResourceAccessor(groups, nameHash) {\n    const uniformsOut = {};\n    for (const i in nameHash) {\n      const data = nameHash[i];\n      Object.defineProperty(uniformsOut, data.name, {\n        get() {\n          return groups[data.group].getResource(data.binding);\n        },\n        set(value) {\n          groups[data.group].setResource(value, data.binding);\n        }\n      });\n    }\n    return uniformsOut;\n  }\n  /**\n   * Use to destroy the shader when its not longer needed.\n   * It will destroy the resources and remove listeners.\n   * @param destroyPrograms - if the programs should be destroyed as well.\n   * Make sure its not being used by other shaders!\n   */\n  destroy(destroyPrograms = false) {\n    this.emit(\"destroy\", this);\n    if (destroyPrograms) {\n      this.gpuProgram?.destroy();\n      this.glProgram?.destroy();\n    }\n    this.gpuProgram = null;\n    this.glProgram = null;\n    this.removeAllListeners();\n    this._uniformBindMap = null;\n    this._ownedBindGroups.forEach((bindGroup) => {\n      bindGroup.destroy();\n    });\n    this._ownedBindGroups = null;\n    this.resources = null;\n    this.groups = null;\n  }\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new Shader({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n}\n\nexport { Shader };\n//# sourceMappingURL=Shader.mjs.map\n","\"use strict\";\nconst UNIFORM_TYPES_VALUES = [\n  \"f32\",\n  \"i32\",\n  \"vec2<f32>\",\n  \"vec3<f32>\",\n  \"vec4<f32>\",\n  \"mat2x2<f32>\",\n  \"mat3x3<f32>\",\n  \"mat4x4<f32>\",\n  \"mat3x2<f32>\",\n  \"mat4x2<f32>\",\n  \"mat2x3<f32>\",\n  \"mat4x3<f32>\",\n  \"mat2x4<f32>\",\n  \"mat3x4<f32>\"\n];\nconst UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) => {\n  acc[type] = true;\n  return acc;\n}, {});\n\nexport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES };\n//# sourceMappingURL=types.mjs.map\n","\"use strict\";\nfunction getDefaultUniformValue(type, size) {\n  switch (type) {\n    case \"f32\":\n      return 0;\n    case \"vec2<f32>\":\n      return new Float32Array(2 * size);\n    case \"vec3<f32>\":\n      return new Float32Array(3 * size);\n    case \"vec4<f32>\":\n      return new Float32Array(4 * size);\n    case \"mat2x2<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case \"mat3x3<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case \"mat4x4<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\n\nexport { getDefaultUniformValue };\n//# sourceMappingURL=getDefaultUniformValue.mjs.map\n","import { uid } from '../../../../utils/data/uid.mjs';\nimport { createIdFromString } from '../utils/createIdFromString.mjs';\nimport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES } from './types.mjs';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue.mjs';\n\n\"use strict\";\nconst _UniformGroup = class _UniformGroup {\n  /**\n   * Create a new Uniform group\n   * @param uniformStructures - The structures of the uniform group\n   * @param options - The optional parameters of this uniform group\n   */\n  constructor(uniformStructures, options) {\n    /** used internally to know if a uniform group was used in the last render pass */\n    this._touched = 0;\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid(\"uniform\");\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    this._resourceType = \"uniformGroup\";\n    /** the resource id used internally by the renderer to build bind group keys */\n    this._resourceId = uid(\"resource\");\n    /** used ito identify if this is a uniform group */\n    this.isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    this._dirtyId = 0;\n    // implementing the interface - UniformGroup are not destroyed\n    this.destroyed = false;\n    options = { ..._UniformGroup.defaultOptions, ...options };\n    this.uniformStructures = uniformStructures;\n    const uniforms = {};\n    for (const i in uniformStructures) {\n      const uniformData = uniformStructures[i];\n      uniformData.name = i;\n      uniformData.size = uniformData.size ?? 1;\n      if (!UNIFORM_TYPES_MAP[uniformData.type]) {\n        throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(\", \")}`);\n      }\n      uniformData.value ?? (uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size));\n      uniforms[i] = uniformData.value;\n    }\n    this.uniforms = uniforms;\n    this._dirtyId = 1;\n    this.ubo = options.ubo;\n    this.isStatic = options.isStatic;\n    this._signature = createIdFromString(Object.keys(uniforms).map(\n      (i) => `${i}-${uniformStructures[i].type}`\n    ).join(\"-\"), \"uniform-group\");\n  }\n  /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n  update() {\n    this._dirtyId++;\n  }\n};\n/** The default options used by the uniform group. */\n_UniformGroup.defaultOptions = {\n  /** if true the UniformGroup is handled as an Uniform buffer object. */\n  ubo: false,\n  /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n  isStatic: false\n};\nlet UniformGroup = _UniformGroup;\n\nexport { UniformGroup };\n//# sourceMappingURL=UniformGroup.mjs.map\n","\"use strict\";\nconst blendModeIds = {\n  normal: 0,\n  add: 1,\n  multiply: 2,\n  screen: 3,\n  overlay: 4,\n  erase: 5,\n  \"normal-npm\": 6,\n  \"add-npm\": 7,\n  \"screen-npm\": 8\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _State = class _State {\n  constructor() {\n    this.data = 0;\n    this.blendMode = \"normal\";\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    if (!!(this.data & 1 << BLEND) !== value) {\n      this.data ^= 1 << BLEND;\n    }\n  }\n  /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    if (!!(this.data & 1 << OFFSET) !== value) {\n      this.data ^= 1 << OFFSET;\n    }\n  }\n  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n  set cullMode(value) {\n    if (value === \"none\") {\n      this.culling = false;\n      return;\n    }\n    this.culling = true;\n    this.clockwiseFrontFace = value === \"front\";\n  }\n  get cullMode() {\n    if (!this.culling) {\n      return \"none\";\n    }\n    return this.clockwiseFrontFace ? \"front\" : \"back\";\n  }\n  /**\n   * Activates culling of polygons.\n   * @default false\n   */\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    if (!!(this.data & 1 << CULLING) !== value) {\n      this.data ^= 1 << CULLING;\n    }\n  }\n  /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    if (!!(this.data & 1 << DEPTH_TEST) !== value) {\n      this.data ^= 1 << DEPTH_TEST;\n    }\n  }\n  /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    if (!!(this.data & 1 << DEPTH_MASK) !== value) {\n      this.data ^= 1 << DEPTH_MASK;\n    }\n  }\n  /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    if (!!(this.data & 1 << WINDING) !== value) {\n      this.data ^= 1 << WINDING;\n    }\n  }\n  /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== \"none\";\n    this._blendMode = value;\n    this._blendModeId = blendModeIds[value] || 0;\n  }\n  /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value;\n    this._polygonOffset = value;\n  }\n  toString() {\n    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n  }\n  /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */\n  static for2d() {\n    const state = new _State();\n    state.depthTest = false;\n    state.blend = true;\n    return state;\n  }\n};\n_State.default2d = _State.for2d();\nlet State = _State;\n\nexport { State };\n//# sourceMappingURL=State.mjs.map\n","import { nextPow2 } from '../../../../maths/misc/pow2.mjs';\nimport { TextureSource } from './sources/TextureSource.mjs';\nimport { Texture } from './Texture.mjs';\n\n\"use strict\";\nlet count = 0;\nclass TexturePoolClass {\n  /**\n   * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n   * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n   */\n  constructor(textureOptions) {\n    this._poolKeyHash = /* @__PURE__ */ Object.create(null);\n    this._texturePool = {};\n    this.textureOptions = textureOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   * @param antialias\n   */\n  createTexture(pixelWidth, pixelHeight, antialias) {\n    const textureSource = new TextureSource({\n      ...this.textureOptions,\n      width: pixelWidth,\n      height: pixelHeight,\n      resolution: 1,\n      antialias,\n      autoGarbageCollect: true\n    });\n    return new Texture({\n      source: textureSource,\n      label: `texturePool_${count++}`\n    });\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param frameWidth - The minimum width of the render texture.\n   * @param frameHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @param antialias\n   * @returns The new render texture.\n   */\n  getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {\n    let po2Width = Math.ceil(frameWidth * resolution - 1e-6);\n    let po2Height = Math.ceil(frameHeight * resolution - 1e-6);\n    po2Width = nextPow2(po2Width);\n    po2Height = nextPow2(po2Height);\n    const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n    if (!this._texturePool[key]) {\n      this._texturePool[key] = [];\n    }\n    let texture = this._texturePool[key].pop();\n    if (!texture) {\n      texture = this.createTexture(po2Width, po2Height, antialias);\n    }\n    texture.source._resolution = resolution;\n    texture.source.width = po2Width / resolution;\n    texture.source.height = po2Height / resolution;\n    texture.source.pixelWidth = po2Width;\n    texture.source.pixelHeight = po2Height;\n    texture.frame.x = 0;\n    texture.frame.y = 0;\n    texture.frame.width = frameWidth;\n    texture.frame.height = frameHeight;\n    texture.updateUvs();\n    this._poolKeyHash[texture.uid] = key;\n    return texture;\n  }\n  /**\n   * Gets extra texture of the same size as input renderTexture\n   * @param texture - The texture to check what size it is.\n   * @param antialias - Whether to use antialias.\n   * @returns A texture that is a power of two\n   */\n  getSameSizeTexture(texture, antialias = false) {\n    const source = texture.source;\n    return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param renderTexture - The renderTexture to free\n   */\n  returnTexture(renderTexture) {\n    const key = this._poolKeyHash[renderTexture.uid];\n    this._texturePool[key].push(renderTexture);\n  }\n  /**\n   * Clears the pool.\n   * @param destroyTextures - Destroy all stored textures.\n   */\n  clear(destroyTextures) {\n    destroyTextures = destroyTextures !== false;\n    if (destroyTextures) {\n      for (const i in this._texturePool) {\n        const textures = this._texturePool[i];\n        if (textures) {\n          for (let j = 0; j < textures.length; j++) {\n            textures[j].destroy(true);\n          }\n        }\n      }\n    }\n    this._texturePool = {};\n  }\n}\nconst TexturePool = new TexturePoolClass();\n\nexport { TexturePool, TexturePoolClass };\n//# sourceMappingURL=TexturePool.mjs.map\n","\"use strict\";\nconst idCounts = /* @__PURE__ */ Object.create(null);\nconst idHash = /* @__PURE__ */ Object.create(null);\nfunction createIdFromString(value, groupId) {\n  let id = idHash[value];\n  if (id === void 0) {\n    if (idCounts[groupId] === void 0) {\n      idCounts[groupId] = 1;\n    }\n    idHash[value] = id = idCounts[groupId]++;\n  }\n  return id;\n}\n\nexport { createIdFromString };\n//# sourceMappingURL=createIdFromString.mjs.map\n","\"use strict\";\nvar RendererType = /* @__PURE__ */ ((RendererType2) => {\n  RendererType2[RendererType2[\"WEBGL\"] = 1] = \"WEBGL\";\n  RendererType2[RendererType2[\"WEBGPU\"] = 2] = \"WEBGPU\";\n  RendererType2[RendererType2[\"BOTH\"] = 3] = \"BOTH\";\n  return RendererType2;\n})(RendererType || {});\n\nexport { RendererType };\n//# sourceMappingURL=types.mjs.map\n","\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexport { color32BitToUniform, colorToUniform };\n//# sourceMappingURL=colorToUniform.mjs.map\n","\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    // batch specific..\n    this.vertexSize = 4;\n    this.indexSize = 6;\n    this.location = 0;\n    // location in the buffer\n    this.batcher = null;\n    this.batch = null;\n    this.roundPixels = 0;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const sprite = this.renderable;\n    const texture = this.texture;\n    const wt = sprite.groupTransform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const bounds = this.bounds;\n    const w0 = bounds.maxX;\n    const w1 = bounds.minX;\n    const h0 = bounds.maxY;\n    const h1 = bounds.minY;\n    const uvs = texture.uvs;\n    const argb = sprite.groupColorAlpha;\n    const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n    float32View[index + 0] = a * w1 + c * h1 + tx;\n    float32View[index + 1] = d * h1 + b * w1 + ty;\n    float32View[index + 2] = uvs.x0;\n    float32View[index + 3] = uvs.y0;\n    uint32View[index + 4] = argb;\n    uint32View[index + 5] = textureIdAndRound;\n    float32View[index + 6] = a * w0 + c * h1 + tx;\n    float32View[index + 7] = d * h1 + b * w0 + ty;\n    float32View[index + 8] = uvs.x1;\n    float32View[index + 9] = uvs.y1;\n    uint32View[index + 10] = argb;\n    uint32View[index + 11] = textureIdAndRound;\n    float32View[index + 12] = a * w0 + c * h0 + tx;\n    float32View[index + 13] = d * h0 + b * w0 + ty;\n    float32View[index + 14] = uvs.x2;\n    float32View[index + 15] = uvs.y2;\n    uint32View[index + 16] = argb;\n    uint32View[index + 17] = textureIdAndRound;\n    float32View[index + 18] = a * w1 + c * h0 + tx;\n    float32View[index + 19] = d * h0 + b * w1 + ty;\n    float32View[index + 20] = uvs.x3;\n    float32View[index + 21] = uvs.y3;\n    uint32View[index + 22] = argb;\n    uint32View[index + 23] = textureIdAndRound;\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    indexBuffer[index] = indicesOffset + 0;\n    indexBuffer[index + 1] = indicesOffset + 1;\n    indexBuffer[index + 2] = indicesOffset + 2;\n    indexBuffer[index + 3] = indicesOffset + 0;\n    indexBuffer[index + 4] = indicesOffset + 2;\n    indexBuffer[index + 5] = indicesOffset + 3;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this.batcher = null;\n    this.batch = null;\n    this.bounds = null;\n  }\n}\n\nexport { BatchableSprite };\n//# sourceMappingURL=BatchableSprite.mjs.map\n"],"names":["addBits","srcParts","parts","name","i","part","toLocaleLowerCase","sanitisedPart","replace","push","warn","findHooksRx","compileHooks","programSrc","match","map","hook","forEach","extractInputs","fragmentSource","out","regex","exec","compileInputs","fragments","template","sort","results","fragment","header","mainInput","finalString","inValue","join","cleanedString","extractOutputs","injectBits","templateSrc","fragmentParts","length","cacheMap","Object","create","bitCacheMap","Map","CACHE_UID","compileHighShaderGl","bits","cacheId","generateCacheId","compileBits","vertex","highFragment","has","set","get","a","b","vertexParts","shaderBit","vertexGPUTemplate","fragmentGPUTemplate","vertexGlTemplate","fragmentGlTemplate","globalUniformsBit","globalUniformsBitGl","compileHighShaderGpuProgram","source","vertexFragments","filter","v","fragmentFragments","compiledVertex","index","mainStruct","indexOf","mainStart","value","mainEnd","extractVariableName","compiledCode","compileOutputs","compileInputsAndOutputs","compileHighShader","GpuProgram","from","entryPoint","compileHighShaderGlProgram","GlProgram","colorBit","main","colorBitGl","textureBatchBitGpuCache","generateBindingSrc","maxTextures","src","bindingIndex","generateSampleSrc","generateTextureBatchBit","end","textureBatchBitGlCache","generateSampleGlSrc","generateTextureBatchBitGl","localUniformBit","localUniformBitGroup2","localUniformBitGl","roundPixelsBit","roundPixelsBitGl","maxFragmentPrecision","getMaxFragmentPrecision","gl","getTestContext","getShaderPrecisionFormat","shaderFragment","FRAGMENT_SHADER","HIGH_FLOAT","precision","fragmentNameCache","VertexNameCache","processes","stripVersion","isES300","ensurePrecision","options","isFragment","maxSupportedPrecision","maxSupportedFragmentPrecision","maxSupportedVertexPrecision","substring","requestedFragmentPrecision","requestedVertexPrecision","addProgramDefines","setProgramName","nameCache","insertVersion","programCache","_GlProgram","constructor","defaultOptions","preprocessorOptions","preferredFragmentPrecision","preferredVertexPrecision","keys","processKey","processOptions","this","_key","createIdFromString","destroy","_attributeData","_uniformData","_uniformBlockData","transformFeedbackVaryings","key","WGSL_TO_VERTEX_TYPES","f32","vec2f","vec3f","vec4f","i32","u32","bool","extractStructAndGroups","wgsl","groupPattern","bindingPattern","namePattern","typePattern","structMemberPattern","structName","groups","item","group","parseInt","binding","isUniform","type","structs","struct","members","reduce","acc","member","name2","split","trim","some","ShaderStage","ShaderStage2","_layoutKey","layout","gpuLayout","structsAndGroups","vertexStructsAndGroups","fragmentStructsAndGroups","structNameSet","Set","dupeGroupKeySet","add","removeStructAndGroupDuplicates","generateLayoutHash","visibility","VERTEX","FRAGMENT","buffer","sampler","texture","sampleType","viewDimension","multisampled","generateGpuLayoutGroups","autoAssignGlobalUniforms","globalUniforms","autoAssignLocalUniforms","localUniforms","_generateProgramKey","bigKey","attributeData","mainVertStart","arrowFunctionStart","functionArgsSubstring","inputsRegex","format","location","stride","getAttributeInfoFromFormat","offset","instance","start","extractAttributesFromGpuProgram","attributeFormatData","uint8x2","size","normalised","uint8x4","sint8x2","sint8x4","unorm8x2","unorm8x4","snorm8x2","snorm8x4","uint16x2","uint16x4","sint16x2","sint16x4","unorm16x2","unorm16x4","snorm16x2","snorm16x4","float16x2","float16x4","float32","float32x2","float32x3","float32x4","uint32","uint32x2","uint32x3","uint32x4","sint32","sint32x2","sint32x3","sint32x4","Shader","super","_uniformBindMap","_ownedBindGroups","gpuProgram","glProgram","resources","compatibleRenderers","groupMap","WEBGPU","WEBGL","nameHash","Error","j","uniformName","groupData","data","bindTick","_resourceType","setResource","_buildResourceAccessor","addResource","groupIndex","bindIndex","_a","_b","uniformsOut","defineProperty","getResource","destroyPrograms","emit","removeAllListeners","bindGroup","gpu","rest","UNIFORM_TYPES_VALUES","UNIFORM_TYPES_MAP","getDefaultUniformValue","Float32Array","_UniformGroup","uniformStructures","_touched","uid","_resourceId","isUniformGroup","_dirtyId","destroyed","uniforms","uniformData","ubo","isStatic","_signature","update","UniformGroup","blendModeIds","normal","multiply","screen","overlay","erase","_State","blendMode","polygonOffset","blend","depthMask","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","toString","for2d","state","default2d","State","count","TexturePool","textureOptions","_poolKeyHash","_texturePool","enableFullScreen","createTexture","pixelWidth","pixelHeight","antialias","textureSource","width","height","resolution","autoGarbageCollect","label","getOptimalTexture","frameWidth","frameHeight","po2Width","Math","ceil","po2Height","pop","_resolution","frame","x","y","updateUvs","getSameSizeTexture","returnTexture","renderTexture","clear","destroyTextures","textures","idCounts","idHash","groupId","id","RendererType","RendererType2","color32BitToUniform","abgr","alpha","BatchableSprite","vertexSize","indexSize","batcher","batch","roundPixels","renderable","groupBlendMode","packAttributes","float32View","uint32View","textureId","sprite","wt","groupTransform","c","d","tx","ty","bounds","w0","maxX","w1","minX","h0","maxY","h1","minY","uvs","argb","groupColorAlpha","textureIdAndRound","x0","y0","x1","y1","x2","y2","x3","y3","packIndex","indexBuffer","indicesOffset","reset"],"sourceRoot":""}