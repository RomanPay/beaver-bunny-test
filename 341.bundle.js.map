{"version":3,"file":"341.bundle.js","mappings":"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","sources":["webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/high-shader/shader-bits/textureBit.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/ensureAttributes.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/gpu/state/GpuStencilModesToPixi.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/buffer/BufferResource.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTarget.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/isRenderingToScreen.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/gpu/renderTarget/calculateProjection.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/UboSystem.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/createUboSyncFunction.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uboSyncFunctions.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/uniformParsers.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/scene/container/CustomRenderPipe.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/scene/container/utils/executeInstructions.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/scene/container/RenderGroupPipe.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/scene/container/utils/buildInstructions.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/scene/container/utils/collectRenderGroups.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/scene/container/utils/mixColors.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/scene/container/utils/mixHexColors.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/scene/container/utils/updateRenderGroupTransforms.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/scene/container/utils/validateRenderables.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/scene/container/RenderGroupSystem.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/scene/sprite/SpritePipe.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/batcher/shared/BatcherPipe.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/filters/Filter.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/filters/mask/mask.frag.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/filters/mask/MaskFilter.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/filters/mask/mask.vert.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/mask/alpha/AlphaMaskPipe.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/mask/color/ColorMaskPipe.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/mask/stencil/StencilMaskPipe.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/background/BackgroundSystem.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/blendModes/BlendModePipe.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/extract/ExtractSystem.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/RenderTexture.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/extract/GenerateTextureSystem.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/renderTarget/GlobalUniformSystem.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/utils/sayHello.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/startup/HelloSystem.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/TextureGCSystem.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/view/ViewSystem.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/system/SharedSystems.mjs","webpack://pixi_webpack_template/./node_modules/pixi.js/lib/rendering/renderers/shared/texture/utils/getCanvasTexture.mjs"],"sourcesContent":["\"use strict\";\nconst textureBit = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n         \n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    )\n  }\n};\nconst textureBitGl = {\n  name: \"texture-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            uniform mat3 uTextureMatrix;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    )\n  },\n  fragment: {\n    header: (\n      /* glsl */\n      `\n        uniform sampler2D uTexture;\n\n         \n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            outColor = texture(uTexture, vUV);\n        `\n    )\n  }\n};\n\nexport { textureBit, textureBitGl };\n//# sourceMappingURL=textureBit.mjs.map\n","import { warn } from '../../../../../utils/logging/warn.mjs';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nfunction ensureAttributes(geometry, extractedData) {\n  for (const i in geometry.attributes) {\n    const attribute = geometry.attributes[i];\n    const attributeData = extractedData[i];\n    if (attributeData) {\n      attribute.location ?? (attribute.location = attributeData.location);\n      attribute.format ?? (attribute.format = attributeData.format);\n      attribute.offset ?? (attribute.offset = attributeData.offset);\n      attribute.instance ?? (attribute.instance = attributeData.instance);\n    } else {\n      warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n    }\n  }\n  ensureStartAndStride(geometry);\n}\nfunction ensureStartAndStride(geometry) {\n  const { buffers, attributes } = geometry;\n  const tempStride = {};\n  const tempStart = {};\n  for (const j in buffers) {\n    const buffer = buffers[j];\n    tempStride[buffer.uid] = 0;\n    tempStart[buffer.uid] = 0;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n  for (const j in attributes) {\n    const attribute = attributes[j];\n    attribute.stride ?? (attribute.stride = tempStride[attribute.buffer.uid]);\n    attribute.start ?? (attribute.start = tempStart[attribute.buffer.uid]);\n    tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n  }\n}\n\nexport { ensureAttributes };\n//# sourceMappingURL=ensureAttributes.mjs.map\n","import { STENCIL_MODES } from '../../shared/state/const.mjs';\n\n\"use strict\";\nconst GpuStencilModesToPixi = [];\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = void 0;\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n  stencilWriteMask: 0,\n  stencilReadMask: 0\n};\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"increment-clamp\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"increment-clamp\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"decrement-clamp\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"decrement-clamp\"\n  }\n};\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n  stencilWriteMask: 0,\n  stencilFront: {\n    compare: \"equal\",\n    passOp: \"keep\"\n  },\n  stencilBack: {\n    compare: \"equal\",\n    passOp: \"keep\"\n  }\n};\n\nexport { GpuStencilModesToPixi };\n//# sourceMappingURL=GpuStencilModesToPixi.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\n\n\"use strict\";\nclass BufferResource extends EventEmitter {\n  /**\n   * Create a new Buffer Resource.\n   * @param options - The options for the buffer resource\n   * @param options.buffer - The underlying buffer that this resource is using\n   * @param options.offset - The offset of the buffer this resource is using.\n   * If not provided, then it will use the offset of the buffer.\n   * @param options.size - The size of the buffer this resource is using.\n   * If not provided, then it will use the size of the buffer.\n   */\n  constructor({ buffer, offset, size }) {\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /**\n     * a unique id for this uniform group used through the renderer\n     * @internal\n     * @ignore\n     */\n    this.uid = uid(\"buffer\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    this._resourceType = \"bufferResource\";\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    this._touched = 0;\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     * @ignore\n     */\n    this._bufferResource = true;\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    this.buffer = buffer;\n    this.offset = offset | 0;\n    this.size = size;\n    this.buffer.on(\"change\", this.onBufferChange, this);\n  }\n  onBufferChange() {\n    this._resourceId = uid(\"resource\");\n    this.emit(\"change\", this);\n  }\n  /**\n   * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n   * if you want to destroy it as well, or code will explode\n   * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n   */\n  destroy(destroyBuffer = false) {\n    this.destroyed = true;\n    if (destroyBuffer) {\n      this.buffer.destroy();\n    }\n    this.emit(\"change\", this);\n    this.buffer = null;\n  }\n}\n\nexport { BufferResource };\n//# sourceMappingURL=BufferResource.mjs.map\n","import { uid } from '../../../../utils/data/uid.mjs';\nimport { TextureSource } from '../texture/sources/TextureSource.mjs';\nimport { Texture } from '../texture/Texture.mjs';\n\n\"use strict\";\nconst _RenderTarget = class _RenderTarget {\n  /**\n   * @param [descriptor] - Options for creating a render target.\n   */\n  constructor(descriptor = {}) {\n    this.uid = uid(\"renderTarget\");\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    this.colorTextures = [];\n    this.dirtyId = 0;\n    this.isRoot = false;\n    this._size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    this._managedColorTextures = false;\n    descriptor = { ..._RenderTarget.defaultOptions, ...descriptor };\n    this.stencil = descriptor.stencil;\n    this.depth = descriptor.depth;\n    this.isRoot = descriptor.isRoot;\n    if (typeof descriptor.colorTextures === \"number\") {\n      this._managedColorTextures = true;\n      for (let i = 0; i < descriptor.colorTextures; i++) {\n        this.colorTextures.push(\n          new TextureSource({\n            width: descriptor.width,\n            height: descriptor.height,\n            resolution: descriptor.resolution,\n            antialias: descriptor.antialias\n          })\n        );\n      }\n    } else {\n      this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n      const colorSource = this.colorTexture.source;\n      this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n    }\n    this.colorTexture.source.on(\"resize\", this.onSourceResize, this);\n    if (descriptor.depthStencilTexture || this.stencil) {\n      if (descriptor.depthStencilTexture instanceof Texture || descriptor.depthStencilTexture instanceof TextureSource) {\n        this.depthStencilTexture = descriptor.depthStencilTexture.source;\n      } else {\n        this.ensureDepthStencilTexture();\n      }\n    }\n  }\n  get size() {\n    const _size = this._size;\n    _size[0] = this.pixelWidth;\n    _size[1] = this.pixelHeight;\n    return _size;\n  }\n  get width() {\n    return this.colorTexture.source.width;\n  }\n  get height() {\n    return this.colorTexture.source.height;\n  }\n  get pixelWidth() {\n    return this.colorTexture.source.pixelWidth;\n  }\n  get pixelHeight() {\n    return this.colorTexture.source.pixelHeight;\n  }\n  get resolution() {\n    return this.colorTexture.source._resolution;\n  }\n  get colorTexture() {\n    return this.colorTextures[0];\n  }\n  onSourceResize(source) {\n    this.resize(source.width, source.height, source._resolution, true);\n  }\n  /**\n   * This will ensure a depthStencil texture is created for this render target.\n   * Most likely called by the mask system to make sure we have stencil buffer added.\n   * @internal\n   * @ignore\n   */\n  ensureDepthStencilTexture() {\n    if (!this.depthStencilTexture) {\n      this.depthStencilTexture = new TextureSource({\n        width: this.width,\n        height: this.height,\n        resolution: this.resolution,\n        format: \"depth24plus-stencil8\",\n        autoGenerateMipmaps: false,\n        antialias: false,\n        mipLevelCount: 1\n        // sampleCount: handled by the render target system..\n      });\n    }\n  }\n  resize(width, height, resolution = this.resolution, skipColorTexture = false) {\n    this.dirtyId++;\n    this.colorTextures.forEach((colorTexture, i) => {\n      if (skipColorTexture && i === 0)\n        return;\n      colorTexture.source.resize(width, height, resolution);\n    });\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.source.resize(width, height, resolution);\n    }\n  }\n  destroy() {\n    this.colorTexture.source.off(\"resize\", this.onSourceResize, this);\n    if (this._managedColorTextures) {\n      this.colorTextures.forEach((texture) => {\n        texture.destroy();\n      });\n    }\n    if (this.depthStencilTexture) {\n      this.depthStencilTexture.destroy();\n      delete this.depthStencilTexture;\n    }\n  }\n};\n/** The default options for a render target */\n_RenderTarget.defaultOptions = {\n  /** the width of the RenderTarget */\n  width: 0,\n  /** the height of the RenderTarget */\n  height: 0,\n  /** the resolution of the RenderTarget */\n  resolution: 1,\n  /** an array of textures, or a number indicating how many color textures there should be */\n  colorTextures: 1,\n  /** should this render target have a stencil buffer? */\n  stencil: false,\n  /** should this render target have a depth buffer? */\n  depth: false,\n  /** should this render target be antialiased? */\n  antialias: false,\n  // save on perf by default!\n  /** is this a root element, true if this is gl context owners render target */\n  isRoot: false\n};\nlet RenderTarget = _RenderTarget;\n\nexport { RenderTarget };\n//# sourceMappingURL=RenderTarget.mjs.map\n","import { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { CLEAR } from '../../gl/const.mjs';\nimport { calculateProjection } from '../../gpu/renderTarget/calculateProjection.mjs';\nimport { SystemRunner } from '../system/SystemRunner.mjs';\nimport { CanvasSource } from '../texture/sources/CanvasSource.mjs';\nimport { TextureSource } from '../texture/sources/TextureSource.mjs';\nimport { Texture } from '../texture/Texture.mjs';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture.mjs';\nimport { isRenderingToScreen } from './isRenderingToScreen.mjs';\nimport { RenderTarget } from './RenderTarget.mjs';\n\n\"use strict\";\nclass RenderTargetSystem {\n  constructor(renderer) {\n    /** This is the root viewport for the render pass*/\n    this.rootViewPort = new Rectangle();\n    /** the current viewport that the gpu is using */\n    this.viewport = new Rectangle();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    this.onRenderTargetChange = new SystemRunner(\"onRenderTargetChange\");\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    this.projectionMatrix = new Matrix();\n    /** the default clear color for render targets */\n    this.defaultClearColor = [0, 0, 0, 0];\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    this._renderTargetStack = [];\n    this._renderer = renderer;\n  }\n  /** called when dev wants to finish a render pass */\n  finishRenderPass() {\n    this.adaptor.finishRenderPass(this.renderTarget);\n  }\n  /**\n   * called when the renderer starts to render a scene.\n   * @param options\n   * @param options.target - the render target to render to\n   * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param options.clearColor - the color to clear to\n   * @param options.frame - the frame to render to\n   */\n  renderStart({\n    target,\n    clear,\n    clearColor,\n    frame\n  }) {\n    this._renderTargetStack.length = 0;\n    this.push(\n      target,\n      clear,\n      clearColor,\n      frame\n    );\n    this.rootViewPort.copyFrom(this.viewport);\n    this.rootRenderTarget = this.renderTarget;\n    this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n  }\n  /**\n   * Binding a render surface! This is the main function of the render target system.\n   * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n   * Once bound all draw calls will be rendered to the render surface.\n   *\n   * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n   * @param renderSurface - the render surface to bind\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to render to\n   * @returns the render target that was bound\n   */\n  bind(renderSurface, clear = true, clearColor, frame) {\n    const renderTarget = this.getRenderTarget(renderSurface);\n    const didChange = this.renderTarget !== renderTarget;\n    this.renderTarget = renderTarget;\n    this.renderSurface = renderSurface;\n    const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n    if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {\n      this.adaptor.resizeGpuRenderTarget(renderTarget);\n      gpuRenderTarget.width = renderTarget.pixelWidth;\n      gpuRenderTarget.height = renderTarget.pixelHeight;\n    }\n    const source = renderTarget.colorTexture;\n    const viewport = this.viewport;\n    const pixelWidth = source.pixelWidth;\n    const pixelHeight = source.pixelHeight;\n    if (!frame && renderSurface instanceof Texture) {\n      frame = renderSurface.frame;\n    }\n    if (frame) {\n      const resolution = source._resolution;\n      viewport.x = frame.x * resolution + 0.5 | 0;\n      viewport.y = frame.y * resolution + 0.5 | 0;\n      viewport.width = frame.width * resolution + 0.5 | 0;\n      viewport.height = frame.height * resolution + 0.5 | 0;\n    } else {\n      viewport.x = 0;\n      viewport.y = 0;\n      viewport.width = pixelWidth;\n      viewport.height = pixelHeight;\n    }\n    calculateProjection(\n      this.projectionMatrix,\n      0,\n      0,\n      viewport.width / source.resolution,\n      viewport.height / source.resolution,\n      !renderTarget.isRoot\n    );\n    this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n    if (didChange) {\n      this.onRenderTargetChange.emit(renderTarget);\n    }\n    return renderTarget;\n  }\n  clear(target, clear = CLEAR.ALL, clearColor) {\n    if (!clear)\n      return;\n    if (target) {\n      target = this.getRenderTarget(target);\n    }\n    this.adaptor.clear(\n      target || this.renderTarget,\n      clear,\n      clearColor,\n      this.viewport\n    );\n  }\n  contextChange() {\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Push a render surface to the renderer. This will bind the render surface to the renderer,\n   * @param renderSurface - the render surface to push\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to use when rendering to the render surface\n   */\n  push(renderSurface, clear = CLEAR.ALL, clearColor, frame) {\n    const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n    this._renderTargetStack.push({\n      renderTarget,\n      frame\n    });\n    return renderTarget;\n  }\n  /** Pops the current render target from the renderer and restores the previous render target. */\n  pop() {\n    this._renderTargetStack.pop();\n    const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n    this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n  }\n  /**\n   * Gets the render target from the provide render surface. Eg if its a texture,\n   * it will return the render target for the texture.\n   * If its a render target, it will return the same render target.\n   * @param renderSurface - the render surface to get the render target for\n   * @returns the render target for the render surface\n   */\n  getRenderTarget(renderSurface) {\n    if (renderSurface.isTexture) {\n      renderSurface = renderSurface.source;\n    }\n    return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);\n  }\n  /**\n   * Copies a render surface to another texture\n   * @param sourceRenderSurfaceTexture - the render surface to copy from\n   * @param destinationTexture - the texture to copy to\n   * @param originSrc - the origin of the copy\n   * @param originSrc.x - the x origin of the copy\n   * @param originSrc.y - the y origin of the copy\n   * @param size - the size of the copy\n   * @param size.width - the width of the copy\n   * @param size.height - the height of the copy\n   * @param originDest - the destination origin (top left to paste from!)\n   * @param originDest.x - the x origin of the paste\n   * @param originDest.y - the y origin of the paste\n   */\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    if (originSrc.x < 0) {\n      size.width += originSrc.x;\n      originDest.x -= originSrc.x;\n      originSrc.x = 0;\n    }\n    if (originSrc.y < 0) {\n      size.height += originSrc.y;\n      originDest.y -= originSrc.y;\n      originSrc.y = 0;\n    }\n    const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n    size.width = Math.min(size.width, pixelWidth - originSrc.x);\n    size.height = Math.min(size.height, pixelHeight - originSrc.y);\n    return this.adaptor.copyToTexture(\n      sourceRenderSurfaceTexture,\n      destinationTexture,\n      originSrc,\n      size,\n      originDest\n    );\n  }\n  /**\n   * ensures that we have a depth stencil buffer available to render to\n   * This is used by the mask system to make sure we have a stencil buffer.\n   */\n  ensureDepthStencil() {\n    if (!this.renderTarget.stencil) {\n      this.renderTarget.stencil = true;\n      this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n    }\n  }\n  /** nukes the render target system */\n  destroy() {\n    this._renderer = null;\n    this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {\n      if (renderTarget !== key) {\n        renderTarget.destroy();\n      }\n    });\n    this._renderSurfaceToRenderTargetHash.clear();\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  _initRenderTarget(renderSurface) {\n    let renderTarget = null;\n    if (CanvasSource.test(renderSurface)) {\n      renderSurface = getCanvasTexture(renderSurface).source;\n    }\n    if (renderSurface instanceof RenderTarget) {\n      renderTarget = renderSurface;\n    } else if (renderSurface instanceof TextureSource) {\n      renderTarget = new RenderTarget({\n        colorTextures: [renderSurface]\n      });\n      if (CanvasSource.test(renderSurface.source.resource)) {\n        renderTarget.isRoot = true;\n      }\n      renderSurface.once(\"destroy\", () => {\n        renderTarget.destroy();\n        const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n        if (gpuRenderTarget) {\n          this._gpuRenderTargetHash[renderTarget.uid] = null;\n          this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n        }\n      });\n    }\n    this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n    return renderTarget;\n  }\n  getGpuRenderTarget(renderTarget) {\n    return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n  }\n}\n\nexport { RenderTargetSystem };\n//# sourceMappingURL=RenderTargetSystem.mjs.map\n","\"use strict\";\nfunction isRenderingToScreen(renderTarget) {\n  const resource = renderTarget.colorTexture.source.resource;\n  return globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement && document.body.contains(resource);\n}\n\nexport { isRenderingToScreen };\n//# sourceMappingURL=isRenderingToScreen.mjs.map\n","\"use strict\";\nfunction calculateProjection(pm, x, y, width, height, flipY) {\n  const sign = flipY ? 1 : -1;\n  pm.identity();\n  pm.a = 1 / width * 2;\n  pm.d = sign * (1 / height * 2);\n  pm.tx = -1 - x * pm.a;\n  pm.ty = -sign - y * pm.d;\n  return pm;\n}\n\nexport { calculateProjection };\n//# sourceMappingURL=calculateProjection.mjs.map\n","import { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported.mjs';\nimport { Buffer } from '../buffer/Buffer.mjs';\nimport { BufferUsage } from '../buffer/const.mjs';\n\n\"use strict\";\nclass UboSystem {\n  constructor(adaptor) {\n    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n    this._syncFunctionHash = /* @__PURE__ */ Object.create(null);\n    this._adaptor = adaptor;\n    this._systemCheck();\n  }\n  /**\n   * Overrideable function by `pixi.js/unsafe-eval` to silence\n   * throwing an error if platform doesn't support unsafe-evals.\n   * @private\n   */\n  _systemCheck() {\n    if (!unsafeEvalSupported()) {\n      throw new Error(\"Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.\");\n    }\n  }\n  ensureUniformGroup(uniformGroup) {\n    const uniformData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new Buffer({\n      data: new Float32Array(uniformData.layout.size / 4),\n      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\n    }));\n  }\n  getUniformGroupData(uniformGroup) {\n    return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n  }\n  _initUniformGroup(uniformGroup) {\n    const uniformGroupSignature = uniformGroup._signature;\n    let uniformData = this._syncFunctionHash[uniformGroupSignature];\n    if (!uniformData) {\n      const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n      const layout = this._adaptor.createUboElements(elements);\n      const syncFunction = this._generateUboSync(layout.uboElements);\n      uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n        layout,\n        syncFunction\n      };\n    }\n    return this._syncFunctionHash[uniformGroupSignature];\n  }\n  _generateUboSync(uboElements) {\n    return this._adaptor.generateUboSync(uboElements);\n  }\n  syncUniformGroup(uniformGroup, data, offset) {\n    const uniformGroupData = this.getUniformGroupData(uniformGroup);\n    uniformGroup.buffer || (uniformGroup.buffer = new Buffer({\n      data: new Float32Array(uniformGroupData.layout.size / 4),\n      usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST\n    }));\n    data || (data = uniformGroup.buffer.data);\n    offset || (offset = 0);\n    uniformGroupData.syncFunction(uniformGroup.uniforms, data, offset);\n    return true;\n  }\n  updateUniformGroup(uniformGroup) {\n    if (uniformGroup.isStatic && !uniformGroup._dirtyId)\n      return false;\n    uniformGroup._dirtyId = 0;\n    const synced = this.syncUniformGroup(uniformGroup);\n    uniformGroup.buffer.update();\n    return synced;\n  }\n  destroy() {\n    this._syncFunctionHash = null;\n  }\n}\n\nexport { UboSystem };\n//# sourceMappingURL=UboSystem.mjs.map\n","import { uniformParsers } from './uniformParsers.mjs';\n\n\"use strict\";\nfunction createUboSyncFunction(uboElements, parserCode, arrayGenerationFunction, singleSettersMap) {\n  const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n  let prev = 0;\n  for (let i = 0; i < uboElements.length; i++) {\n    const uboElement = uboElements[i];\n    const name = uboElement.data.name;\n    let parsed = false;\n    let offset = 0;\n    for (let j = 0; j < uniformParsers.length; j++) {\n      const uniformParser = uniformParsers[j];\n      if (uniformParser.test(uboElement.data)) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          `name = \"${name}\";`,\n          `offset += ${offset - prev};`,\n          uniformParsers[j][parserCode] || uniformParsers[j].ubo\n        );\n        parsed = true;\n        break;\n      }\n    }\n    if (!parsed) {\n      if (uboElement.data.size > 1) {\n        offset = uboElement.offset / 4;\n        funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n      } else {\n        const template = singleSettersMap[uboElement.data.type];\n        offset = uboElement.offset / 4;\n        funcFragments.push(\n          /* wgsl */\n          `\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `\n        );\n      }\n    }\n    prev = offset;\n  }\n  const fragmentSrc = funcFragments.join(\"\\n\");\n  return new Function(\n    \"uv\",\n    \"data\",\n    \"offset\",\n    fragmentSrc\n  );\n}\n\nexport { createUboSyncFunction };\n//# sourceMappingURL=createUboSyncFunction.mjs.map\n","\"use strict\";\nfunction loopMatrix(col, row) {\n  const total = col * row;\n  return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\nconst uboSyncFunctionsSTD40 = {\n  f32: `\n        data[offset] = v;`,\n  i32: `\n        data[offset] = v;`,\n  \"vec2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n  \"vec3<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n  \"vec4<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n  \"mat2x2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n  \"mat3x3<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n  \"mat4x4<f32>\": `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n  \"mat3x2<f32>\": loopMatrix(3, 2),\n  \"mat4x2<f32>\": loopMatrix(4, 2),\n  \"mat2x3<f32>\": loopMatrix(2, 3),\n  \"mat4x3<f32>\": loopMatrix(4, 3),\n  \"mat2x4<f32>\": loopMatrix(2, 4),\n  \"mat3x4<f32>\": loopMatrix(3, 4)\n};\nconst uboSyncFunctionsWGSL = {\n  ...uboSyncFunctionsSTD40,\n  \"mat2x2<f32>\": `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `\n};\n\nexport { uboSyncFunctionsSTD40, uboSyncFunctionsWGSL };\n//# sourceMappingURL=uboSyncFunctions.mjs.map\n","\"use strict\";\nconst uniformParsers = [\n  // uploading pixi matrix object to mat3\n  {\n    type: \"mat3x3<f32>\",\n    test: (data) => {\n      const value = data.value;\n      return value.a !== void 0;\n    },\n    ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n    uniform: ` \n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n  },\n  // uploading a pixi rectangle as a vec4\n  {\n    type: \"vec4<f32>\",\n    test: (data) => data.type === \"vec4<f32>\" && data.size === 1 && data.value.width !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n  },\n  // uploading a pixi point as a vec2\n  {\n    type: \"vec2<f32>\",\n    test: (data) => data.type === \"vec2<f32>\" && data.size === 1 && data.value.x !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n  },\n  // uploading a pixi color as a vec4\n  {\n    type: \"vec4<f32>\",\n    test: (data) => data.type === \"vec4<f32>\" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n  },\n  // uploading a pixi color as a vec3\n  {\n    type: \"vec3<f32>\",\n    test: (data) => data.type === \"vec3<f32>\" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n  }\n];\n\nexport { uniformParsers };\n//# sourceMappingURL=uniformParsers.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass CustomRenderPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderable(container, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(container);\n  }\n  execute(container) {\n    if (!container.isRenderable)\n      return;\n    container.render(this._renderer);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nCustomRenderPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"customRender\"\n};\n\nexport { CustomRenderPipe };\n//# sourceMappingURL=CustomRenderPipe.mjs.map\n","\"use strict\";\nfunction executeInstructions(renderGroup, renderer) {\n  const instructionSet = renderGroup.instructionSet;\n  const instructions = instructionSet.instructions;\n  for (let i = 0; i < instructionSet.instructionSize; i++) {\n    const instruction = instructions[i];\n    renderer[instruction.renderPipeId].execute(instruction);\n  }\n}\n\nexport { executeInstructions };\n//# sourceMappingURL=executeInstructions.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { executeInstructions } from './utils/executeInstructions.mjs';\n\n\"use strict\";\nclass RenderGroupPipe {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  addRenderGroup(renderGroup, instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add(renderGroup);\n  }\n  execute(renderGroup) {\n    if (!renderGroup.isRenderable)\n      return;\n    this._renderer.globalUniforms.push({\n      worldTransformMatrix: renderGroup.worldTransform,\n      worldColor: renderGroup.worldColorAlpha\n    });\n    executeInstructions(renderGroup, this._renderer.renderPipes);\n    this._renderer.globalUniforms.pop();\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\nRenderGroupPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"renderGroup\"\n};\n\nexport { RenderGroupPipe };\n//# sourceMappingURL=RenderGroupPipe.mjs.map\n","\"use strict\";\nfunction buildInstructions(renderGroup, renderPipes) {\n  const root = renderGroup.root;\n  const instructionSet = renderGroup.instructionSet;\n  instructionSet.reset();\n  renderPipes.batch.buildStart(instructionSet);\n  renderPipes.blendMode.buildStart();\n  renderPipes.colorMask.buildStart();\n  if (root.sortableChildren) {\n    root.sortChildren();\n  }\n  collectAllRenderablesAdvanced(root, instructionSet, renderPipes, true);\n  renderPipes.batch.buildEnd(instructionSet);\n  renderPipes.blendMode.buildEnd(instructionSet);\n}\nfunction collectAllRenderables(container, instructionSet, rendererPipes) {\n  if (container.globalDisplayStatus < 7 || !container.includeInBuild)\n    return;\n  if (container.sortableChildren) {\n    container.sortChildren();\n  }\n  if (container.isSimple) {\n    collectAllRenderablesSimple(container, instructionSet, rendererPipes);\n  } else {\n    collectAllRenderablesAdvanced(container, instructionSet, rendererPipes, false);\n  }\n}\nfunction collectAllRenderablesSimple(container, instructionSet, renderPipes) {\n  if (container.renderPipeId) {\n    renderPipes.blendMode.setBlendMode(container, container.groupBlendMode, instructionSet);\n    container.didViewUpdate = false;\n    const rp = renderPipes;\n    rp[container.renderPipeId].addRenderable(container, instructionSet);\n  }\n  if (!container.renderGroup) {\n    const children = container.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      collectAllRenderables(children[i], instructionSet, renderPipes);\n    }\n  }\n}\nfunction collectAllRenderablesAdvanced(container, instructionSet, renderPipes, isRoot) {\n  if (!isRoot && container.renderGroup) {\n    renderPipes.renderGroup.addRenderGroup(container.renderGroup, instructionSet);\n  } else {\n    for (let i = 0; i < container.effects.length; i++) {\n      const effect = container.effects[i];\n      const pipe = renderPipes[effect.pipe];\n      pipe.push(effect, container, instructionSet);\n    }\n    const renderPipeId = container.renderPipeId;\n    if (renderPipeId) {\n      renderPipes.blendMode.setBlendMode(container, container.groupBlendMode, instructionSet);\n      container.didViewUpdate = false;\n      const pipe = renderPipes[renderPipeId];\n      pipe.addRenderable(container, instructionSet);\n    }\n    const children = container.children;\n    if (children.length) {\n      for (let i = 0; i < children.length; i++) {\n        collectAllRenderables(children[i], instructionSet, renderPipes);\n      }\n    }\n    for (let i = container.effects.length - 1; i >= 0; i--) {\n      const effect = container.effects[i];\n      const pipe = renderPipes[effect.pipe];\n      pipe.pop(effect, container, instructionSet);\n    }\n  }\n}\n\nexport { buildInstructions, collectAllRenderables };\n//# sourceMappingURL=buildInstructions.mjs.map\n","\"use strict\";\nfunction collectRenderGroups(renderGroup, out = []) {\n  out.push(renderGroup);\n  for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n    collectRenderGroups(renderGroup.renderGroupChildren[i], out);\n  }\n  return out;\n}\n\nexport { collectRenderGroups };\n//# sourceMappingURL=collectRenderGroups.mjs.map\n","import { mixHexColors } from './mixHexColors.mjs';\n\n\"use strict\";\nconst WHITE_BGR = 16777215;\nfunction mixColors(localBGRColor, parentBGRColor) {\n  if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR) {\n    return localBGRColor + parentBGRColor - WHITE_BGR;\n  }\n  return mixHexColors(localBGRColor, parentBGRColor, 0.5);\n}\nfunction mixStandardAnd32BitColors(localColorRGB, localAlpha, parentColor) {\n  const parentAlpha = (parentColor >> 24 & 255) / 255;\n  const globalAlpha = localAlpha * parentAlpha * 255;\n  const localBGRColor = ((localColorRGB & 255) << 16) + (localColorRGB & 65280) + (localColorRGB >> 16 & 255);\n  const parentBGRColor = parentColor & 16777215;\n  let sharedBGRColor;\n  if (localBGRColor === WHITE_BGR || parentBGRColor === WHITE_BGR) {\n    sharedBGRColor = localBGRColor + parentBGRColor - WHITE_BGR;\n  } else {\n    sharedBGRColor = mixHexColors(localBGRColor, parentBGRColor, 0.5);\n  }\n  return sharedBGRColor + (globalAlpha << 24);\n}\n\nexport { mixColors, mixStandardAnd32BitColors };\n//# sourceMappingURL=mixColors.mjs.map\n","\"use strict\";\nfunction mixHexColors(color1, color2, ratio) {\n  const r1 = color1 >> 16 & 255;\n  const g1 = color1 >> 8 & 255;\n  const b1 = color1 & 255;\n  const r2 = color2 >> 16 & 255;\n  const g2 = color2 >> 8 & 255;\n  const b2 = color2 & 255;\n  const r = r1 + (r2 - r1) * ratio;\n  const g = g1 + (g2 - g1) * ratio;\n  const b = b1 + (b2 - b1) * ratio;\n  return (r << 16) + (g << 8) + b;\n}\n\nexport { mixHexColors };\n//# sourceMappingURL=mixHexColors.mjs.map\n","import { Container, UPDATE_COLOR, UPDATE_BLEND, UPDATE_VISIBLE } from '../Container.mjs';\nimport { mixColors } from './mixColors.mjs';\n\n\"use strict\";\nconst tempContainer = new Container();\nfunction updateRenderGroupTransforms(renderGroup, updateChildRenderGroups = false) {\n  updateRenderGroupTransform(renderGroup);\n  const childrenToUpdate = renderGroup.childrenToUpdate;\n  const updateTick = renderGroup.updateTick++;\n  for (const j in childrenToUpdate) {\n    const childrenAtDepth = childrenToUpdate[j];\n    const list = childrenAtDepth.list;\n    const index = childrenAtDepth.index;\n    for (let i = 0; i < index; i++) {\n      const child = list[i];\n      if (child.parentRenderGroup === renderGroup) {\n        updateTransformAndChildren(child, updateTick, 0);\n      }\n    }\n    childrenAtDepth.index = 0;\n  }\n  if (updateChildRenderGroups) {\n    for (let i = 0; i < renderGroup.renderGroupChildren.length; i++) {\n      updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n    }\n  }\n}\nfunction updateRenderGroupTransform(renderGroup) {\n  const root = renderGroup.root;\n  let worldAlpha;\n  if (renderGroup.renderGroupParent) {\n    const renderGroupParent = renderGroup.renderGroupParent;\n    renderGroup.worldTransform.appendFrom(\n      root.relativeGroupTransform,\n      renderGroupParent.worldTransform\n    );\n    renderGroup.worldColor = mixColors(\n      root.groupColor,\n      renderGroupParent.worldColor\n    );\n    worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n  } else {\n    renderGroup.worldTransform.copyFrom(root.localTransform);\n    renderGroup.worldColor = root.localColor;\n    worldAlpha = root.localAlpha;\n  }\n  worldAlpha = worldAlpha < 0 ? 0 : worldAlpha > 1 ? 1 : worldAlpha;\n  renderGroup.worldAlpha = worldAlpha;\n  renderGroup.worldColorAlpha = renderGroup.worldColor + ((worldAlpha * 255 | 0) << 24);\n}\nfunction updateTransformAndChildren(container, updateTick, updateFlags) {\n  if (updateTick === container.updateTick)\n    return;\n  container.updateTick = updateTick;\n  container.didChange = false;\n  const localTransform = container.localTransform;\n  container.updateLocalTransform();\n  const parent = container.parent;\n  if (parent && !parent.renderGroup) {\n    updateFlags = updateFlags | container._updateFlags;\n    container.relativeGroupTransform.appendFrom(\n      localTransform,\n      parent.relativeGroupTransform\n    );\n    if (updateFlags) {\n      updateColorBlendVisibility(container, parent, updateFlags);\n    }\n  } else {\n    updateFlags = container._updateFlags;\n    container.relativeGroupTransform.copyFrom(localTransform);\n    if (updateFlags) {\n      updateColorBlendVisibility(container, tempContainer, updateFlags);\n    }\n  }\n  if (!container.renderGroup) {\n    const children = container.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      updateTransformAndChildren(children[i], updateTick, updateFlags);\n    }\n    const renderGroup = container.parentRenderGroup;\n    if (container.renderPipeId && !renderGroup.structureDidChange) {\n      renderGroup.updateRenderable(container);\n    }\n  }\n}\nfunction updateColorBlendVisibility(container, parent, updateFlags) {\n  if (updateFlags & UPDATE_COLOR) {\n    container.groupColor = mixColors(\n      container.localColor,\n      parent.groupColor\n    );\n    let groupAlpha = container.localAlpha * parent.groupAlpha;\n    groupAlpha = groupAlpha < 0 ? 0 : groupAlpha > 1 ? 1 : groupAlpha;\n    container.groupAlpha = groupAlpha;\n    container.groupColorAlpha = container.groupColor + ((groupAlpha * 255 | 0) << 24);\n  }\n  if (updateFlags & UPDATE_BLEND) {\n    container.groupBlendMode = container.localBlendMode === \"inherit\" ? parent.groupBlendMode : container.localBlendMode;\n  }\n  if (updateFlags & UPDATE_VISIBLE) {\n    container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n  }\n  container._updateFlags = 0;\n}\n\nexport { updateRenderGroupTransform, updateRenderGroupTransforms, updateTransformAndChildren };\n//# sourceMappingURL=updateRenderGroupTransforms.mjs.map\n","\"use strict\";\nfunction validateRenderables(renderGroup, renderPipes) {\n  const { list, index } = renderGroup.childrenRenderablesToUpdate;\n  let rebuildRequired = false;\n  for (let i = 0; i < index; i++) {\n    const container = list[i];\n    const renderable = container;\n    const pipe = renderPipes[renderable.renderPipeId];\n    rebuildRequired = pipe.validateRenderable(container);\n    if (rebuildRequired) {\n      break;\n    }\n  }\n  renderGroup.structureDidChange = rebuildRequired;\n  return rebuildRequired;\n}\n\nexport { validateRenderables };\n//# sourceMappingURL=validateRenderables.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { buildInstructions } from './utils/buildInstructions.mjs';\nimport { collectRenderGroups } from './utils/collectRenderGroups.mjs';\nimport { executeInstructions } from './utils/executeInstructions.mjs';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms.mjs';\nimport { validateRenderables } from './utils/validateRenderables.mjs';\n\n\"use strict\";\nconst tempMatrix = new Matrix();\nclass RenderGroupSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  render({ container, transform }) {\n    container.isRenderGroup = true;\n    const parent = container.parent;\n    const renderGroupParent = container.renderGroup.renderGroupParent;\n    container.parent = null;\n    container.renderGroup.renderGroupParent = null;\n    const renderer = this._renderer;\n    const renderGroups = collectRenderGroups(container.renderGroup, []);\n    let originalLocalTransform = tempMatrix;\n    if (transform) {\n      originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n      container.renderGroup.localTransform.copyFrom(transform);\n    }\n    const renderPipes = renderer.renderPipes;\n    for (let i = 0; i < renderGroups.length; i++) {\n      const renderGroup = renderGroups[i];\n      renderGroup.runOnRender();\n      renderGroup.instructionSet.renderPipes = renderPipes;\n      if (!renderGroup.structureDidChange) {\n        validateRenderables(renderGroup, renderPipes);\n      }\n      updateRenderGroupTransforms(renderGroup);\n      if (renderGroup.structureDidChange) {\n        renderGroup.structureDidChange = false;\n        buildInstructions(renderGroup, renderPipes);\n      } else {\n        updateRenderables(renderGroup);\n      }\n      renderGroup.childrenRenderablesToUpdate.index = 0;\n      renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n    }\n    renderer.globalUniforms.start({\n      worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n      worldColor: container.renderGroup.worldColorAlpha\n    });\n    executeInstructions(container.renderGroup, renderPipes);\n    if (renderPipes.uniformBatch) {\n      renderPipes.uniformBatch.renderEnd();\n    }\n    if (transform) {\n      container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n    }\n    container.parent = parent;\n    container.renderGroup.renderGroupParent = renderGroupParent;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nRenderGroupSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"renderGroup\"\n};\nfunction updateRenderables(renderGroup) {\n  const { list, index } = renderGroup.childrenRenderablesToUpdate;\n  for (let i = 0; i < index; i++) {\n    const container = list[i];\n    if (container.didViewUpdate) {\n      renderGroup.updateRenderable(container);\n    }\n  }\n}\n\nexport { RenderGroupSystem };\n//# sourceMappingURL=RenderGroupSystem.mjs.map\n","import { ExtensionType } from '../../extensions/Extensions.mjs';\nimport { BigPool } from '../../utils/pool/PoolGroup.mjs';\nimport { BatchableSprite } from './BatchableSprite.mjs';\n\n\"use strict\";\nclass SpritePipe {\n  constructor(renderer) {\n    this._gpuSpriteHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  addRenderable(sprite, _instructionSet) {\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (sprite._didSpriteUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    this._renderer.renderPipes.batch.addToBatch(gpuSprite);\n  }\n  updateRenderable(sprite) {\n    const gpuSprite = this._gpuSpriteHash[sprite.uid];\n    if (sprite._didSpriteUpdate)\n      this._updateBatchableSprite(sprite, gpuSprite);\n    gpuSprite.batcher.updateElement(gpuSprite);\n  }\n  validateRenderable(sprite) {\n    const texture = sprite._texture;\n    const gpuSprite = this._getGpuSprite(sprite);\n    if (gpuSprite.texture._source !== texture._source) {\n      return !gpuSprite.batcher.checkAndUpdateTexture(gpuSprite, texture);\n    }\n    return false;\n  }\n  destroyRenderable(sprite) {\n    const batchableSprite = this._gpuSpriteHash[sprite.uid];\n    BigPool.return(batchableSprite);\n    this._gpuSpriteHash[sprite.uid] = null;\n  }\n  _updateBatchableSprite(sprite, batchableSprite) {\n    sprite._didSpriteUpdate = false;\n    batchableSprite.bounds = sprite.bounds;\n    batchableSprite.texture = sprite._texture;\n  }\n  _getGpuSprite(sprite) {\n    return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n  }\n  _initGPUSprite(sprite) {\n    const batchableSprite = BigPool.get(BatchableSprite);\n    batchableSprite.renderable = sprite;\n    batchableSprite.texture = sprite._texture;\n    batchableSprite.bounds = sprite.bounds;\n    batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;\n    this._gpuSpriteHash[sprite.uid] = batchableSprite;\n    sprite._didSpriteUpdate = false;\n    sprite.on(\"destroyed\", () => {\n      this.destroyRenderable(sprite);\n    });\n    return batchableSprite;\n  }\n  destroy() {\n    for (const i in this._gpuSpriteHash) {\n      BigPool.return(this._gpuSpriteHash[i]);\n    }\n    this._gpuSpriteHash = null;\n    this._renderer = null;\n  }\n}\n/** @ignore */\nSpritePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"sprite\"\n};\n\nexport { SpritePipe };\n//# sourceMappingURL=SpritePipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { State } from '../../renderers/shared/state/State.mjs';\nimport { BatchGeometry } from '../gpu/BatchGeometry.mjs';\nimport { Batcher } from './Batcher.mjs';\n\n\"use strict\";\nclass BatcherPipe {\n  constructor(renderer, adaptor) {\n    this.state = State.for2d();\n    this._batches = /* @__PURE__ */ Object.create(null);\n    this._geometries = /* @__PURE__ */ Object.create(null);\n    this.renderer = renderer;\n    this._adaptor = adaptor;\n    this._adaptor.init(this);\n  }\n  buildStart(instructionSet) {\n    if (!this._batches[instructionSet.uid]) {\n      const batcher = new Batcher();\n      this._batches[instructionSet.uid] = batcher;\n      this._geometries[batcher.uid] = new BatchGeometry();\n    }\n    this._activeBatch = this._batches[instructionSet.uid];\n    this._activeGeometry = this._geometries[this._activeBatch.uid];\n    this._activeBatch.begin();\n  }\n  addToBatch(batchableObject) {\n    this._activeBatch.add(batchableObject);\n  }\n  break(instructionSet) {\n    this._activeBatch.break(instructionSet);\n  }\n  buildEnd(instructionSet) {\n    const activeBatch = this._activeBatch;\n    const geometry = this._activeGeometry;\n    activeBatch.finish(instructionSet);\n    geometry.indexBuffer.setDataWithSize(activeBatch.indexBuffer, activeBatch.indexSize, true);\n    geometry.buffers[0].setDataWithSize(activeBatch.attributeBuffer.float32View, activeBatch.attributeSize, false);\n  }\n  upload(instructionSet) {\n    const batcher = this._batches[instructionSet.uid];\n    const geometry = this._geometries[batcher.uid];\n    if (batcher.dirty) {\n      batcher.dirty = false;\n      geometry.buffers[0].update(batcher.attributeSize * 4);\n    }\n  }\n  execute(batch) {\n    if (batch.action === \"startBatch\") {\n      const batcher = batch.batcher;\n      const geometry = this._geometries[batcher.uid];\n      this._adaptor.start(this, geometry);\n    }\n    this._adaptor.execute(this, batch);\n  }\n  destroy() {\n    this.state = null;\n    this.renderer = null;\n    this._adaptor.destroy();\n    this._adaptor = null;\n    for (const i in this._batches) {\n      this._batches[i].destroy();\n    }\n    this._batches = null;\n    for (const i in this._geometries) {\n      this._geometries[i].destroy();\n    }\n    this._geometries = null;\n  }\n}\n/** @ignore */\nBatcherPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"batch\"\n};\n\nexport { BatcherPipe };\n//# sourceMappingURL=BatcherPipe.mjs.map\n","import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader.mjs';\nimport { State } from '../rendering/renderers/shared/state/State.mjs';\n\n\"use strict\";\nconst _Filter = class _Filter extends Shader {\n  /**\n   * @param options - The optional parameters of this filter.\n   */\n  constructor(options) {\n    options = { ..._Filter.defaultOptions, ...options };\n    super(options);\n    /** If enabled is true the filter is applied, if false it will not. */\n    this.enabled = true;\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     * @ignore\n     */\n    this._state = State.for2d();\n    this.padding = options.padding;\n    if (typeof options.antialias === \"boolean\") {\n      this.antialias = options.antialias ? \"on\" : \"off\";\n    } else {\n      this.antialias = options.antialias;\n    }\n    this.resolution = options.resolution;\n    this.blendRequired = options.blendRequired;\n    this.addResource(\"uTexture\", 0, 1);\n  }\n  /**\n   * Applies the filter\n   * @param filterManager - The renderer to retrieve the filter from\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it\n   */\n  apply(filterManager, input, output, clearMode) {\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Get the blend mode of the filter.\n   * @default \"normal\"\n   */\n  get blendMode() {\n    return this._state.blendMode;\n  }\n  /** Sets the blend mode of the filter. */\n  set blendMode(value) {\n    this._state.blendMode = value;\n  }\n  /**\n   * A short hand function to create a filter based of a vertex and fragment shader src.\n   * @param options\n   * @returns A shiny new PixiJS filter!\n   */\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new _Filter({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n};\n/**\n * The default filter settings\n * @static\n */\n_Filter.defaultOptions = {\n  blendMode: \"normal\",\n  resolution: 1,\n  padding: 0,\n  antialias: \"off\",\n  blendRequired: false\n};\nlet Filter = _Filter;\n\nexport { Filter };\n//# sourceMappingURL=Filter.mjs.map\n","var fragment = \"in vec2 vMaskCoord;\\nin vec2 vTextureCoord;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMaskTexture;\\n\\nuniform float uAlpha;\\nuniform vec4 uMaskClamp;\\n\\nout vec4 finalColor;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(uMaskClamp.x, vMaskCoord.x) +\\n        step(uMaskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, uMaskClamp.z) +\\n        step(vMaskCoord.y, uMaskClamp.w));\\n\\n    // TODO look into why this is needed\\n    float npmAlpha = uAlpha; \\n    vec4 original = texture(uTexture, vTextureCoord);\\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\\n\\n    original *= (alphaMul * masky.r * uAlpha * clip);\\n\\n    finalColor = original;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=mask.frag.mjs.map\n","var source = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,  \\n};\\n\\nstruct MaskUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uMaskClamp:vec4<f32>,\\n  uAlpha:f32,\\n};\\n\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n\\n  \\n  return gfu.uGlobalFrame.zw;\\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var maskClamp = filterUniforms.uMaskClamp;\\n\\n     var clip = step(3.5,\\n        step(maskClamp.x, filterUv.x) +\\n        step(maskClamp.y, filterUv.y) +\\n        step(filterUv.x, maskClamp.z) +\\n        step(filterUv.y, maskClamp.w));\\n\\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\\n    var source = textureSample(uTexture, uSampler, uv);\\n    \\n    var npmAlpha = 0.0;\\n\\n    var alphaMul = 1.0 - npmAlpha * (1.0 - mask.a);\\n\\n    var a = (alphaMul * mask.r) * clip;\\n\\n    return vec4(source.rgb, source.a) * a;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=mask.wgsl.mjs.map\n","import { Matrix } from '../../maths/matrix/Matrix.mjs';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram.mjs';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup.mjs';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix.mjs';\nimport { Filter } from '../Filter.mjs';\nimport fragment from './mask.frag.mjs';\nimport vertex from './mask.vert.mjs';\nimport source from './mask.wgsl.mjs';\n\n\"use strict\";\nclass MaskFilter extends Filter {\n  constructor(options) {\n    const { sprite, ...rest } = options;\n    const textureMatrix = new TextureMatrix(sprite.texture);\n    const filterUniforms = new UniformGroup({\n      uFilterMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uMaskClamp: { value: textureMatrix.uClampFrame, type: \"vec4<f32>\" },\n      uAlpha: { value: 1, type: \"f32\" }\n    });\n    const gpuProgram = GpuProgram.from({\n      vertex: {\n        source,\n        entryPoint: \"mainVertex\"\n      },\n      fragment: {\n        source,\n        entryPoint: \"mainFragment\"\n      }\n    });\n    const glProgram = GlProgram.from({\n      vertex,\n      fragment,\n      name: \"mask-filter\"\n    });\n    super({\n      ...rest,\n      gpuProgram,\n      glProgram,\n      resources: {\n        filterUniforms,\n        uMaskTexture: sprite.texture.source\n      }\n    });\n    this.sprite = sprite;\n    this._textureMatrix = textureMatrix;\n  }\n  apply(filterManager, input, output, clearMode) {\n    this._textureMatrix.texture = this.sprite.texture;\n    filterManager.calculateSpriteMatrix(\n      this.resources.filterUniforms.uniforms.uFilterMatrix,\n      this.sprite\n    ).prepend(this._textureMatrix.mapCoord);\n    this.resources.uMaskTexture = this.sprite.texture.source;\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n}\n\nexport { MaskFilter };\n//# sourceMappingURL=MaskFilter.mjs.map\n","var vertex = \"in vec2 aPosition;\\n\\nout vec2 vTextureCoord;\\nout vec2 vMaskCoord;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition(  vec2 aPosition )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n       \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord(  vec2 aPosition )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( vec2 aPosition )\\n{\\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}   \\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition(aPosition);\\n    vTextureCoord = filterTextureCoord(aPosition);\\n    vMaskCoord = getFilterCoord(aPosition);\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=mask.vert.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { FilterEffect } from '../../../filters/FilterEffect.mjs';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter.mjs';\nimport { Bounds } from '../../../scene/container/bounds/Bounds.mjs';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds.mjs';\nimport { collectAllRenderables } from '../../../scene/container/utils/buildInstructions.mjs';\nimport { Sprite } from '../../../scene/sprite/Sprite.mjs';\nimport { BigPool } from '../../../utils/pool/PoolGroup.mjs';\nimport { Texture } from '../../renderers/shared/texture/Texture.mjs';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool.mjs';\n\n\"use strict\";\nconst tempBounds = new Bounds();\nclass AlphaMaskEffect extends FilterEffect {\n  constructor() {\n    super();\n    this.filters = [new MaskFilter({\n      sprite: new Sprite(Texture.EMPTY)\n    })];\n  }\n  get sprite() {\n    return this.filters[0].sprite;\n  }\n  set sprite(value) {\n    this.filters[0].sprite = value;\n  }\n}\nclass AlphaMaskPipe {\n  constructor(renderer) {\n    this._activeMaskStage = [];\n    this._renderer = renderer;\n  }\n  push(mask, maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      canBundle: false,\n      maskedContainer\n    });\n    if (mask.renderMaskToTexture) {\n      const maskContainer = mask.mask;\n      maskContainer.includeInBuild = true;\n      collectAllRenderables(\n        maskContainer,\n        instructionSet,\n        renderer.renderPipes\n      );\n      maskContainer.includeInBuild = false;\n    }\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      maskedContainer,\n      canBundle: false\n    });\n  }\n  pop(mask, _maskedContainer, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"alphaMask\",\n      action: \"popMaskEnd\",\n      mask,\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    const renderMask = instruction.mask.renderMaskToTexture;\n    if (instruction.action === \"pushMaskBegin\") {\n      const filterEffect = BigPool.get(AlphaMaskEffect);\n      if (renderMask) {\n        instruction.mask.mask.measurable = true;\n        const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n        instruction.mask.mask.measurable = false;\n        bounds.ceil();\n        const filterTexture = TexturePool.getOptimalTexture(\n          bounds.width,\n          bounds.height,\n          1,\n          false\n        );\n        renderer.renderTarget.push(filterTexture, true);\n        renderer.globalUniforms.push({\n          offset: bounds,\n          worldColor: 4294967295\n        });\n        const sprite = filterEffect.sprite;\n        sprite.texture = filterTexture;\n        sprite.worldTransform.tx = bounds.minX;\n        sprite.worldTransform.ty = bounds.minY;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer,\n          filterTexture\n        });\n      } else {\n        filterEffect.sprite = instruction.mask.mask;\n        this._activeMaskStage.push({\n          filterEffect,\n          maskedContainer: instruction.maskedContainer\n        });\n      }\n    } else if (instruction.action === \"pushMaskEnd\") {\n      const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n      if (renderMask) {\n        renderer.renderTarget.pop();\n        renderer.globalUniforms.pop();\n      }\n      renderer.filter.push({\n        renderPipeId: \"filter\",\n        action: \"pushFilter\",\n        container: maskData.maskedContainer,\n        filterEffect: maskData.filterEffect,\n        canBundle: false\n      });\n    } else if (instruction.action === \"popMaskEnd\") {\n      renderer.filter.pop();\n      const maskData = this._activeMaskStage.pop();\n      if (renderMask) {\n        TexturePool.returnTexture(maskData.filterTexture);\n      }\n      BigPool.return(maskData.filterEffect);\n    }\n  }\n  destroy() {\n    this._renderer = null;\n    this._activeMaskStage = null;\n  }\n}\n/** @ignore */\nAlphaMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"alphaMask\"\n};\n\nexport { AlphaMaskPipe };\n//# sourceMappingURL=AlphaMaskPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\n\n\"use strict\";\nclass ColorMaskPipe {\n  constructor(renderer) {\n    this._colorStack = [];\n    this._colorStackIndex = 0;\n    this._currentColor = 0;\n    this._renderer = renderer;\n  }\n  buildStart() {\n    this._colorStack[0] = 15;\n    this._colorStackIndex = 1;\n    this._currentColor = 15;\n  }\n  push(mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & mask.mask;\n    const currentColor = this._colorStack[this._colorStackIndex];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: \"colorMask\",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n    this._colorStackIndex++;\n  }\n  pop(_mask, _container, instructionSet) {\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    const colorStack = this._colorStack;\n    this._colorStackIndex--;\n    const currentColor = colorStack[this._colorStackIndex - 1];\n    if (currentColor !== this._currentColor) {\n      this._currentColor = currentColor;\n      instructionSet.add({\n        renderPipeId: \"colorMask\",\n        colorMask: currentColor,\n        canBundle: false\n      });\n    }\n  }\n  execute(instruction) {\n    const renderer = this._renderer;\n    renderer.colorMask.setMask(instruction.colorMask);\n  }\n  destroy() {\n    this._colorStack = null;\n  }\n}\n/** @ignore */\nColorMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"colorMask\"\n};\n\nexport { ColorMaskPipe };\n//# sourceMappingURL=ColorMaskPipe.mjs.map\n","import { ExtensionType } from '../../../extensions/Extensions.mjs';\nimport { collectAllRenderables } from '../../../scene/container/utils/buildInstructions.mjs';\nimport { CLEAR } from '../../renderers/gl/const.mjs';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const.mjs';\n\n\"use strict\";\nclass StencilMaskPipe {\n  constructor(renderer) {\n    // used when building and also when executing..\n    this._maskStackHash = {};\n    this._maskHash = /* @__PURE__ */ new WeakMap();\n    this._renderer = renderer;\n  }\n  push(mask, _container, instructionSet) {\n    var _a;\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskBegin\",\n      mask,\n      canBundle: false\n    });\n    const maskContainer = effect.mask;\n    maskContainer.includeInBuild = true;\n    if (!this._maskHash.has(effect)) {\n      this._maskHash.set(effect, {\n        instructionsStart: 0,\n        instructionsLength: 0\n      });\n    }\n    const maskData = this._maskHash.get(effect);\n    maskData.instructionsStart = instructionSet.instructionSize;\n    collectAllRenderables(\n      maskContainer,\n      instructionSet,\n      renderer.renderPipes\n    );\n    maskContainer.includeInBuild = false;\n    renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"pushMaskEnd\",\n      mask,\n      canBundle: false\n    });\n    const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n    maskData.instructionsLength = instructionsLength;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n  }\n  pop(mask, _container, instructionSet) {\n    const effect = mask;\n    const renderer = this._renderer;\n    renderer.renderPipes.batch.break(instructionSet);\n    renderer.renderPipes.blendMode.setBlendMode(effect.mask, \"none\", instructionSet);\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskBegin\",\n      canBundle: false\n    });\n    const maskData = this._maskHash.get(mask);\n    for (let i = 0; i < maskData.instructionsLength; i++) {\n      instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n    }\n    instructionSet.add({\n      renderPipeId: \"stencilMask\",\n      action: \"popMaskEnd\",\n      canBundle: false\n    });\n  }\n  execute(instruction) {\n    var _a;\n    const renderer = this._renderer;\n    const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n    let maskStackIndex = (_a = this._maskStackHash)[renderTargetUid] ?? (_a[renderTargetUid] = 0);\n    if (instruction.action === \"pushMaskBegin\") {\n      renderer.renderTarget.ensureDepthStencil();\n      renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n      maskStackIndex++;\n      renderer.colorMask.setMask(0);\n    } else if (instruction.action === \"pushMaskEnd\") {\n      renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      renderer.colorMask.setMask(15);\n    } else if (instruction.action === \"popMaskBegin\") {\n      renderer.colorMask.setMask(0);\n      if (maskStackIndex !== 0) {\n        renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n      } else {\n        renderer.renderTarget.clear(null, CLEAR.STENCIL);\n        renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n      }\n      maskStackIndex--;\n    } else if (instruction.action === \"popMaskEnd\") {\n      renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n      renderer.colorMask.setMask(15);\n    }\n    this._maskStackHash[renderTargetUid] = maskStackIndex;\n  }\n  destroy() {\n    this._renderer = null;\n    this._maskStackHash = null;\n    this._maskHash = null;\n  }\n}\nStencilMaskPipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"stencilMask\"\n};\n\nexport { StencilMaskPipe };\n//# sourceMappingURL=StencilMaskPipe.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst _BackgroundSystem = class _BackgroundSystem {\n  constructor() {\n    this.clearBeforeRender = true;\n    this._backgroundColor = new Color(0);\n    this.color = this._backgroundColor;\n    this.alpha = 1;\n  }\n  /**\n   * initiates the background system\n   * @param options - the options for the background colors\n   */\n  init(options) {\n    options = { ..._BackgroundSystem.defaultOptions, ...options };\n    this.clearBeforeRender = options.clearBeforeRender;\n    this.color = options.background || options.backgroundColor || this._backgroundColor;\n    this.alpha = options.backgroundAlpha;\n    this._backgroundColor.setAlpha(options.backgroundAlpha);\n  }\n  /** The background color to fill if not transparent */\n  get color() {\n    return this._backgroundColor;\n  }\n  set color(value) {\n    this._backgroundColor.setValue(value);\n  }\n  /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n  get alpha() {\n    return this._backgroundColor.alpha;\n  }\n  set alpha(value) {\n    this._backgroundColor.setAlpha(value);\n  }\n  /** The background color as an [R, G, B, A] array. */\n  get colorRgba() {\n    return this._backgroundColor.toArray();\n  }\n  /**\n   * destroys the background system\n   * @internal\n   * @ignore\n   */\n  destroy() {\n  }\n};\n/** @ignore */\n_BackgroundSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"background\",\n  priority: 0\n};\n/** default options used by the system */\n_BackgroundSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.backgroundAlpha}\n   * @default 1\n   */\n  backgroundAlpha: 1,\n  /**\n   * {@link WebGLOptions.backgroundColor}\n   * @default 0x000000\n   */\n  backgroundColor: 0,\n  /**\n   * {@link WebGLOptions.clearBeforeRender}\n   * @default true\n   */\n  clearBeforeRender: true\n};\nlet BackgroundSystem = _BackgroundSystem;\n\nexport { BackgroundSystem };\n//# sourceMappingURL=BackgroundSystem.mjs.map\n","import { extensions, ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { FilterEffect } from '../../../../filters/FilterEffect.mjs';\nimport { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nconst BLEND_MODE_FILTERS = {};\nextensions.handle(ExtensionType.BlendMode, (value) => {\n  if (!value.name) {\n    throw new Error(\"BlendMode extension must have a name property\");\n  }\n  BLEND_MODE_FILTERS[value.name] = value.ref;\n}, (value) => {\n  delete BLEND_MODE_FILTERS[value.name];\n});\nclass BlendModePipe {\n  constructor(renderer) {\n    this._isAdvanced = false;\n    this._filterHash = /* @__PURE__ */ Object.create(null);\n    this._renderer = renderer;\n  }\n  /**\n   * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.\n   * @param renderable - The renderable we are adding to the instruction set\n   * @param blendMode - The blend mode of the renderable\n   * @param instructionSet - The instruction set we are adding to\n   */\n  setBlendMode(renderable, blendMode, instructionSet) {\n    if (this._activeBlendMode === blendMode) {\n      if (this._isAdvanced)\n        this._renderableList.push(renderable);\n      return;\n    }\n    this._activeBlendMode = blendMode;\n    if (this._isAdvanced) {\n      this._endAdvancedBlendMode(instructionSet);\n    }\n    this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n    if (this._isAdvanced) {\n      this._beginAdvancedBlendMode(instructionSet);\n      this._renderableList.push(renderable);\n    }\n  }\n  _beginAdvancedBlendMode(instructionSet) {\n    this._renderer.renderPipes.batch.break(instructionSet);\n    const blendMode = this._activeBlendMode;\n    if (!BLEND_MODE_FILTERS[blendMode]) {\n      warn(`Unable to assign BlendMode: '${blendMode}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);\n      return;\n    }\n    let filterEffect = this._filterHash[blendMode];\n    if (!filterEffect) {\n      filterEffect = this._filterHash[blendMode] = new FilterEffect();\n      filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode]()];\n    }\n    const instruction = {\n      renderPipeId: \"filter\",\n      action: \"pushFilter\",\n      renderables: [],\n      filterEffect,\n      canBundle: false\n    };\n    this._renderableList = instruction.renderables;\n    instructionSet.add(instruction);\n  }\n  _endAdvancedBlendMode(instructionSet) {\n    this._renderableList = null;\n    this._renderer.renderPipes.batch.break(instructionSet);\n    instructionSet.add({\n      renderPipeId: \"filter\",\n      action: \"popFilter\",\n      canBundle: false\n    });\n  }\n  /**\n   * called when the instruction build process is starting this will reset internally to the default blend mode\n   * @internal\n   * @ignore\n   */\n  buildStart() {\n    this._isAdvanced = false;\n  }\n  /**\n   * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n   * active, we add the final render instructions added to the instruction set\n   * @param instructionSet - The instruction set we are adding to\n   * @internal\n   * @ignore\n   */\n  buildEnd(instructionSet) {\n    if (this._isAdvanced) {\n      this._endAdvancedBlendMode(instructionSet);\n    }\n  }\n  /**\n   * @internal\n   * @ignore\n   */\n  destroy() {\n    this._renderer = null;\n    this._renderableList = null;\n    for (const i in this._filterHash) {\n      this._filterHash[i].destroy();\n    }\n    this._filterHash = null;\n  }\n}\n/** @ignore */\nBlendModePipe.extension = {\n  type: [\n    ExtensionType.WebGLPipes,\n    ExtensionType.WebGPUPipes,\n    ExtensionType.CanvasPipes\n  ],\n  name: \"blendMode\"\n};\n\nexport { BlendModePipe };\n//# sourceMappingURL=BlendModePipe.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { Texture } from '../texture/Texture.mjs';\n\n\"use strict\";\nconst imageTypes = {\n  png: \"image/png\",\n  jpg: \"image/jpeg\",\n  webp: \"image/webp\"\n};\nconst _ExtractSystem = class _ExtractSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  _normalizeOptions(options, defaults = {}) {\n    if (options instanceof Container || options instanceof Texture) {\n      return {\n        target: options,\n        ...defaults\n      };\n    }\n    return {\n      ...defaults,\n      ...options\n    };\n  }\n  /**\n   * Will return a HTML Image of the target\n   * @param options - The options for creating the image, or the target to extract\n   * @returns - HTML Image of the target\n   */\n  async image(options) {\n    const image = new Image();\n    image.src = await this.base64(options);\n    return image;\n  }\n  /**\n   * Will return a base64 encoded string of this target. It works by calling\n   * `Extract.canvas` and then running toDataURL on that.\n   * @param options - The options for creating the image, or the target to extract\n   */\n  async base64(options) {\n    options = this._normalizeOptions(\n      options,\n      _ExtractSystem.defaultImageOptions\n    );\n    const { format, quality } = options;\n    const canvas = this.canvas(options);\n    if (canvas.toBlob !== void 0) {\n      return new Promise((resolve, reject) => {\n        canvas.toBlob((blob) => {\n          if (!blob) {\n            reject(new Error(\"ICanvas.toBlob failed!\"));\n            return;\n          }\n          const reader = new FileReader();\n          reader.onload = () => resolve(reader.result);\n          reader.onerror = reject;\n          reader.readAsDataURL(blob);\n        }, imageTypes[format], quality);\n      });\n    }\n    if (canvas.toDataURL !== void 0) {\n      return canvas.toDataURL(imageTypes[format], quality);\n    }\n    if (canvas.convertToBlob !== void 0) {\n      const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n      });\n    }\n    throw new Error(\"Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented\");\n  }\n  /**\n   * Creates a Canvas element, renders this target to it and then returns it.\n   * @param options - The options for creating the canvas, or the target to extract\n   * @returns - A Canvas element with the texture rendered on.\n   */\n  canvas(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    if (target instanceof Texture) {\n      return renderer.texture.generateCanvas(target);\n    }\n    const texture = renderer.textureGenerator.generateTexture(options);\n    const canvas = renderer.texture.generateCanvas(texture);\n    texture.destroy();\n    return canvas;\n  }\n  /**\n   * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n   * order, with integer values between 0 and 255 (included).\n   * @param options - The options for extracting the image, or the target to extract\n   * @returns - One-dimensional array containing the pixel data of the entire texture\n   */\n  pixels(options) {\n    options = this._normalizeOptions(options);\n    const target = options.target;\n    const renderer = this._renderer;\n    const texture = target instanceof Texture ? target : renderer.textureGenerator.generateTexture(options);\n    const pixelInfo = renderer.texture.getPixels(texture);\n    if (target instanceof Container) {\n      texture.destroy();\n    }\n    return pixelInfo;\n  }\n  /**\n   * Will return a texture of the target\n   * @param options - The options for creating the texture, or the target to extract\n   * @returns - A texture of the target\n   */\n  texture(options) {\n    options = this._normalizeOptions(options);\n    if (options.target instanceof Texture)\n      return options.target;\n    return this._renderer.textureGenerator.generateTexture(options);\n  }\n  /**\n   * Will extract a HTMLImage of the target and download it\n   * @param options - The options for downloading and extracting the image, or the target to extract\n   */\n  download(options) {\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const link = document.createElement(\"a\");\n    link.download = options.filename ?? \"image.png\";\n    link.href = canvas.toDataURL(\"image/png\");\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n  }\n  /**\n   * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n   * @param options - The options for logging the image, or the target to log\n   */\n  log(options) {\n    const width = options.width ?? 200;\n    options = this._normalizeOptions(options);\n    const canvas = this.canvas(options);\n    const base64 = canvas.toDataURL();\n    console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n    const style = [\n      \"font-size: 1px;\",\n      `padding: ${width}px ${300}px;`,\n      `background: url(${base64}) no-repeat;`,\n      \"background-size: contain;\"\n    ].join(\" \");\n    console.log(\"%c \", style);\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_ExtractSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"extract\"\n};\n/** Default options for creating an image. */\n_ExtractSystem.defaultImageOptions = {\n  /** The format of the image. */\n  format: \"png\",\n  /** The quality of the image. */\n  quality: 1\n};\nlet ExtractSystem = _ExtractSystem;\n\nexport { ExtractSystem };\n//# sourceMappingURL=ExtractSystem.mjs.map\n","import { TextureSource } from './sources/TextureSource.mjs';\nimport { Texture } from './Texture.mjs';\n\n\"use strict\";\nclass RenderTexture extends Texture {\n  static create(options) {\n    return new Texture({\n      source: new TextureSource(options)\n    });\n  }\n  /**\n   * Resizes the render texture.\n   * @param width - The new width of the render texture.\n   * @param height - The new height of the render texture.\n   * @param resolution - The new resolution of the render texture.\n   * @returns This texture.\n   */\n  resize(width, height, resolution) {\n    this.source.resize(width, height, resolution);\n    return this;\n  }\n}\n\nexport { RenderTexture };\n//# sourceMappingURL=RenderTexture.mjs.map\n","import { Color } from '../../../../color/Color.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds.mjs';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds.mjs';\nimport { Container } from '../../../../scene/container/Container.mjs';\nimport { RenderTexture } from '../texture/RenderTexture.mjs';\n\n\"use strict\";\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor = [0, 0, 0, 0];\nclass GenerateTextureSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * A Useful function that returns a texture of the display object that can then be used to create sprites\n   * This can be quite useful if your container is complicated and needs to be reused multiple times.\n   * @param {GenerateTextureOptions | Container} options - Generate texture options.\n   * @param {Container} [options.container] - If not given, the renderer's resolution is used.\n   * @param {Rectangle} options.region - The region of the container, that shall be rendered,\n   * @param {number} [options.resolution] - The resolution of the texture being generated.\n   *        if no region is specified, defaults to the local bounds of the container.\n   * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.\n   * @returns a shiny new texture of the container passed in\n   */\n  generateTexture(options) {\n    if (options instanceof Container) {\n      options = {\n        target: options,\n        frame: void 0,\n        textureSourceOptions: {},\n        resolution: void 0\n      };\n    }\n    const resolution = options.resolution || this._renderer.resolution;\n    const antialias = options.antialias || this._renderer.view.antialias;\n    const container = options.target;\n    let clearColor = options.clearColor;\n    if (clearColor) {\n      const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n      clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n    } else {\n      clearColor = noColor;\n    }\n    const region = options.frame?.copyTo(tempRect) || getLocalBounds(container, tempBounds).rectangle;\n    region.width = Math.max(region.width, 1 / resolution) | 0;\n    region.height = Math.max(region.height, 1 / resolution) | 0;\n    const target = RenderTexture.create({\n      ...options.textureSourceOptions,\n      width: region.width,\n      height: region.height,\n      resolution,\n      antialias\n    });\n    const transform = Matrix.shared.translate(-region.x, -region.y);\n    this._renderer.render({\n      container,\n      transform,\n      target,\n      clearColor\n    });\n    return target;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGenerateTextureSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"textureGenerator\"\n};\n\nexport { GenerateTextureSystem };\n//# sourceMappingURL=GenerateTextureSystem.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Matrix } from '../../../../maths/matrix/Matrix.mjs';\nimport { Point } from '../../../../maths/point/Point.mjs';\nimport { color32BitToUniform } from '../../../../scene/graphics/gpu/colorToUniform.mjs';\nimport { BindGroup } from '../../gpu/shader/BindGroup.mjs';\nimport { RendererType } from '../../types.mjs';\nimport { UniformGroup } from '../shader/UniformGroup.mjs';\n\n\"use strict\";\nclass GlobalUniformSystem {\n  constructor(renderer) {\n    this._stackIndex = 0;\n    this._globalUniformDataStack = [];\n    this._uniformsPool = [];\n    this._activeUniforms = [];\n    this._bindGroupPool = [];\n    this._activeBindGroups = [];\n    this._renderer = renderer;\n  }\n  reset() {\n    this._stackIndex = 0;\n    for (let i = 0; i < this._activeUniforms.length; i++) {\n      this._uniformsPool.push(this._activeUniforms[i]);\n    }\n    for (let i = 0; i < this._activeBindGroups.length; i++) {\n      this._bindGroupPool.push(this._activeBindGroups[i]);\n    }\n    this._activeUniforms.length = 0;\n    this._activeBindGroups.length = 0;\n  }\n  start(options) {\n    this.reset();\n    this.push(options);\n  }\n  bind({\n    size,\n    projectionMatrix,\n    worldTransformMatrix,\n    worldColor,\n    offset\n  }) {\n    const renderTarget = this._renderer.renderTarget.renderTarget;\n    const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n      projectionData: renderTarget,\n      worldTransformMatrix: new Matrix(),\n      worldColor: 4294967295,\n      offset: new Point()\n    };\n    const globalUniformData = {\n      projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n      resolution: size || renderTarget.size,\n      worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n      worldColor: worldColor || currentGlobalUniformData.worldColor,\n      offset: offset || currentGlobalUniformData.offset,\n      bindGroup: null\n    };\n    const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n    this._activeUniforms.push(uniformGroup);\n    const uniforms = uniformGroup.uniforms;\n    uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n    uniforms.uResolution = globalUniformData.resolution;\n    uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n    uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n    uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n    color32BitToUniform(\n      globalUniformData.worldColor,\n      uniforms.uWorldColorAlpha,\n      0\n    );\n    uniformGroup.update();\n    let bindGroup;\n    if (this._renderer.renderPipes.uniformBatch) {\n      bindGroup = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n    } else {\n      bindGroup = this._bindGroupPool.pop() || new BindGroup();\n      this._activeBindGroups.push(bindGroup);\n      bindGroup.setResource(uniformGroup, 0);\n    }\n    globalUniformData.bindGroup = bindGroup;\n    this._currentGlobalUniformData = globalUniformData;\n  }\n  push(options) {\n    this.bind(options);\n    this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n  }\n  pop() {\n    this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n    if (this._renderer.type === RendererType.WEBGL) {\n      this._currentGlobalUniformData.bindGroup.resources[0].update();\n    }\n  }\n  get bindGroup() {\n    return this._currentGlobalUniformData.bindGroup;\n  }\n  get uniformGroup() {\n    return this._currentGlobalUniformData.bindGroup.resources[0];\n  }\n  _createUniforms() {\n    const globalUniforms = new UniformGroup({\n      uProjectionMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      uWorldTransformMatrix: { value: new Matrix(), type: \"mat3x3<f32>\" },\n      // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n      uWorldColorAlpha: { value: new Float32Array(4), type: \"vec4<f32>\" },\n      uResolution: { value: [0, 0], type: \"vec2<f32>\" }\n    }, {\n      isStatic: true\n    });\n    return globalUniforms;\n  }\n  destroy() {\n    this._renderer = null;\n  }\n}\n/** @ignore */\nGlobalUniformSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"globalUniforms\"\n};\n\nexport { GlobalUniformSystem };\n//# sourceMappingURL=GlobalUniformSystem.mjs.map\n","import { DOMAdapter } from '../environment/adapter.mjs';\n\n\"use strict\";\nlet saidHello = false;\nconst VERSION = \"8.1.5\";\nfunction sayHello(type) {\n  if (saidHello) {\n    return;\n  }\n  if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf(\"chrome\") > -1) {\n    const args = [\n      `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\n\n`,\n      \"background: #E72264; padding:5px 0;\",\n      \"background: #6CA2EA; padding:5px 0;\",\n      \"background: #B5D33D; padding:5px 0;\",\n      \"background: #FED23F; padding:5px 0;\",\n      \"color: #FFFFFF; background: #E72264; padding:5px 0;\",\n      \"color: #E72264; background: #FFFFFF; padding:5px 0;\"\n    ];\n    globalThis.console.log(...args);\n  } else if (globalThis.console) {\n    globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n  }\n  saidHello = true;\n}\n\nexport { VERSION, sayHello };\n//# sourceMappingURL=sayHello.mjs.map\n","import { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { sayHello } from '../../../../utils/sayHello.mjs';\nimport { RendererType } from '../../types.mjs';\n\n\"use strict\";\nclass HelloSystem {\n  constructor(renderer) {\n    this._renderer = renderer;\n  }\n  /**\n   * It all starts here! This initiates every system, passing in the options for any system by name.\n   * @param options - the config for the renderer and all its systems\n   */\n  init(options) {\n    if (options.hello) {\n      let name = this._renderer.name;\n      if (this._renderer.type === RendererType.WEBGL) {\n        name += ` ${this._renderer.context.webGLVersion}`;\n      }\n      sayHello(name);\n    }\n  }\n}\n/** @ignore */\nHelloSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"hello\",\n  priority: -2\n};\n/** The default options for the system. */\nHelloSystem.defaultOptions = {\n  /** {@link WebGLOptions.hello} */\n  hello: false\n};\n\nexport { HelloSystem };\n//# sourceMappingURL=HelloSystem.mjs.map\n","import { ExtensionType, extensions } from '../../../../extensions/Extensions.mjs';\n\n\"use strict\";\nconst _TextureGCSystem = class _TextureGCSystem {\n  /** @param renderer - The renderer this System works for. */\n  constructor(renderer) {\n    this._renderer = renderer;\n    this.count = 0;\n    this.checkCount = 0;\n  }\n  init(options) {\n    options = { ..._TextureGCSystem.defaultOptions, ...options };\n    this.checkCountMax = options.textureGCCheckCountMax;\n    this.maxIdle = options.textureGCAMaxIdle;\n    this.active = options.textureGCActive;\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */\n  postrender() {\n    if (!this._renderer.renderingToScreen) {\n      return;\n    }\n    this.count++;\n    if (!this.active)\n      return;\n    this.checkCount++;\n    if (this.checkCount > this.checkCountMax) {\n      this.checkCount = 0;\n      this.run();\n    }\n  }\n  /**\n   * Checks to see when the last time a texture was used.\n   * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n   */\n  run() {\n    const managedTextures = this._renderer.texture.managedTextures;\n    for (let i = 0; i < managedTextures.length; i++) {\n      const texture = managedTextures[i];\n      if (texture.autoGarbageCollect && texture.resource && texture._touched > -1 && this.count - texture._touched > this.maxIdle) {\n        texture._touched = -1;\n        texture.unload();\n      }\n    }\n  }\n  destroy() {\n    this._renderer = null;\n  }\n};\n/** @ignore */\n_TextureGCSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem\n  ],\n  name: \"textureGC\"\n};\n/** default options for the TextureGCSystem */\n_TextureGCSystem.defaultOptions = {\n  /**\n   * If set to true, this will enable the garbage collector on the GPU.\n   * @default true\n   */\n  textureGCActive: true,\n  /**\n   * The maximum idle frames before a texture is destroyed by garbage collection.\n   * @default 60 * 60\n   */\n  textureGCAMaxIdle: 60 * 60,\n  /**\n   * Frames between two garbage collections.\n   * @default 600\n   */\n  textureGCCheckCountMax: 600\n};\nlet TextureGCSystem = _TextureGCSystem;\nextensions.add(TextureGCSystem);\n\nexport { TextureGCSystem };\n//# sourceMappingURL=TextureGCSystem.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { ExtensionType } from '../../../../extensions/Extensions.mjs';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle.mjs';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation.mjs';\nimport { RenderTarget } from '../renderTarget/RenderTarget.mjs';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture.mjs';\n\n\"use strict\";\nconst _ViewSystem = class _ViewSystem {\n  /** The resolution / device pixel ratio of the renderer. */\n  get resolution() {\n    return this.texture.source._resolution;\n  }\n  set resolution(value) {\n    this.texture.source.resize(\n      this.texture.source.width,\n      this.texture.source.height,\n      value\n    );\n  }\n  /**\n   * initiates the view system\n   * @param options - the options for the view\n   */\n  init(options) {\n    options = {\n      ..._ViewSystem.defaultOptions,\n      ...options\n    };\n    if (options.view) {\n      deprecation(v8_0_0, \"ViewSystem.view has been renamed to ViewSystem.canvas\");\n      options.canvas = options.view;\n    }\n    this.screen = new Rectangle(0, 0, options.width, options.height);\n    this.canvas = options.canvas || DOMAdapter.get().createCanvas();\n    this.antialias = !!options.antialias;\n    this.texture = getCanvasTexture(this.canvas, options);\n    this.renderTarget = new RenderTarget({\n      colorTextures: [this.texture],\n      depth: !!options.depth,\n      isRoot: true\n    });\n    this.texture.source.transparent = options.backgroundAlpha < 1;\n    this.multiView = !!options.multiView;\n    if (this.autoDensity) {\n      this.canvas.style.width = `${this.texture.width}px`;\n      this.canvas.style.height = `${this.texture.height}px`;\n    }\n    this.resolution = options.resolution;\n  }\n  /**\n   * Resizes the screen and canvas to the specified dimensions.\n   * @param desiredScreenWidth - The new width of the screen.\n   * @param desiredScreenHeight - The new height of the screen.\n   * @param resolution\n   */\n  resize(desiredScreenWidth, desiredScreenHeight, resolution) {\n    this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n    this.screen.width = this.texture.frame.width;\n    this.screen.height = this.texture.frame.height;\n    if (this.autoDensity) {\n      this.canvas.style.width = `${desiredScreenWidth}px`;\n      this.canvas.style.height = `${desiredScreenHeight}px`;\n    }\n  }\n  /**\n   * Destroys this System and optionally removes the canvas from the dom.\n   * @param {options | false} options - The options for destroying the view, or \"false\".\n   * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.\n   */\n  destroy(options = false) {\n    const removeView = typeof options === \"boolean\" ? options : !!options?.removeView;\n    if (removeView && this.canvas.parentNode) {\n      this.canvas.parentNode.removeChild(this.canvas);\n    }\n  }\n};\n/** @ignore */\n_ViewSystem.extension = {\n  type: [\n    ExtensionType.WebGLSystem,\n    ExtensionType.WebGPUSystem,\n    ExtensionType.CanvasSystem\n  ],\n  name: \"view\",\n  priority: 0\n};\n/** The default options for the view system. */\n_ViewSystem.defaultOptions = {\n  /**\n   * {@link WebGLOptions.width}\n   * @default 800\n   */\n  width: 800,\n  /**\n   * {@link WebGLOptions.height}\n   * @default 600\n   */\n  height: 600,\n  /**\n   * {@link WebGLOptions.autoDensity}\n   * @default false\n   */\n  autoDensity: false,\n  /**\n   * {@link WebGLOptions.antialias}\n   * @default false\n   */\n  antialias: false\n};\nlet ViewSystem = _ViewSystem;\n\nexport { ViewSystem };\n//# sourceMappingURL=ViewSystem.mjs.map\n","import { CustomRenderPipe } from '../../../../scene/container/CustomRenderPipe.mjs';\nimport { RenderGroupPipe } from '../../../../scene/container/RenderGroupPipe.mjs';\nimport { RenderGroupSystem } from '../../../../scene/container/RenderGroupSystem.mjs';\nimport { SpritePipe } from '../../../../scene/sprite/SpritePipe.mjs';\nimport { BatcherPipe } from '../../../batcher/shared/BatcherPipe.mjs';\nimport { AlphaMaskPipe } from '../../../mask/alpha/AlphaMaskPipe.mjs';\nimport { ColorMaskPipe } from '../../../mask/color/ColorMaskPipe.mjs';\nimport { StencilMaskPipe } from '../../../mask/stencil/StencilMaskPipe.mjs';\nimport { BackgroundSystem } from '../background/BackgroundSystem.mjs';\nimport { BlendModePipe } from '../blendModes/BlendModePipe.mjs';\nimport { ExtractSystem } from '../extract/ExtractSystem.mjs';\nimport { GenerateTextureSystem } from '../extract/GenerateTextureSystem.mjs';\nimport { GlobalUniformSystem } from '../renderTarget/GlobalUniformSystem.mjs';\nimport { HelloSystem } from '../startup/HelloSystem.mjs';\nimport { TextureGCSystem } from '../texture/TextureGCSystem.mjs';\nimport { ViewSystem } from '../view/ViewSystem.mjs';\n\n\"use strict\";\nconst SharedSystems = [\n  BackgroundSystem,\n  GlobalUniformSystem,\n  HelloSystem,\n  ViewSystem,\n  RenderGroupSystem,\n  TextureGCSystem,\n  GenerateTextureSystem,\n  ExtractSystem\n];\nconst SharedRenderPipes = [\n  BlendModePipe,\n  BatcherPipe,\n  SpritePipe,\n  RenderGroupPipe,\n  AlphaMaskPipe,\n  StencilMaskPipe,\n  ColorMaskPipe,\n  CustomRenderPipe\n];\n\nexport { SharedRenderPipes, SharedSystems };\n//# sourceMappingURL=SharedSystems.mjs.map\n","import { CanvasSource } from '../sources/CanvasSource.mjs';\nimport { Texture } from '../Texture.mjs';\n\n\"use strict\";\nconst canvasCache = /* @__PURE__ */ new Map();\nfunction getCanvasTexture(canvas, options) {\n  if (!canvasCache.has(canvas)) {\n    const texture = new Texture({\n      source: new CanvasSource({\n        resource: canvas,\n        ...options\n      })\n    });\n    const onDestroy = () => {\n      if (canvasCache.get(canvas) === texture) {\n        canvasCache.delete(canvas);\n      }\n    };\n    texture.once(\"destroy\", onDestroy);\n    texture.source.once(\"destroy\", onDestroy);\n    canvasCache.set(canvas, texture);\n  }\n  return canvasCache.get(canvas);\n}\nfunction hasCachedCanvasTexture(canvas) {\n  return canvasCache.has(canvas);\n}\n\nexport { getCanvasTexture, hasCachedCanvasTexture };\n//# sourceMappingURL=getCanvasTexture.mjs.map\n"],"names":["textureBit","name","vertex","header","main","fragment","textureBitGl","ensureAttributes","geometry","extractedData","i","attributes","attribute","attributeData","location","format","offset","instance","buffers","tempStride","tempStart","j","buffer","uid","stride","start","ensureStartAndStride","GpuStencilModesToPixi","NONE","DISABLED","stencilWriteMask","stencilReadMask","RENDERING_MASK_ADD","stencilFront","compare","passOp","stencilBack","RENDERING_MASK_REMOVE","MASK_ACTIVE","BufferResource","constructor","size","super","this","_resourceType","_touched","_resourceId","_bufferResource","destroyed","on","onBufferChange","emit","destroy","destroyBuffer","_RenderTarget","descriptor","colorTextures","dirtyId","isRoot","_size","Float32Array","_managedColorTextures","defaultOptions","stencil","depth","push","width","height","resolution","antialias","map","texture","source","colorSource","colorTexture","resize","_resolution","onSourceResize","depthStencilTexture","ensureDepthStencilTexture","pixelWidth","pixelHeight","autoGenerateMipmaps","mipLevelCount","skipColorTexture","forEach","off","RenderTarget","RenderTargetSystem","renderer","rootViewPort","Rectangle","viewport","onRenderTargetChange","SystemRunner","projectionMatrix","Matrix","defaultClearColor","_renderSurfaceToRenderTargetHash","Map","_gpuRenderTargetHash","Object","create","_renderTargetStack","_renderer","finishRenderPass","adaptor","renderTarget","renderStart","target","clear","clearColor","frame","length","copyFrom","rootRenderTarget","renderingToScreen","resource","globalThis","HTMLCanvasElement","document","body","contains","isRenderingToScreen","bind","renderSurface","getRenderTarget","didChange","gpuRenderTarget","getGpuRenderTarget","resizeGpuRenderTarget","Texture","x","y","pm","flipY","sign","identity","a","d","tx","ty","calculateProjection","startRenderPass","ALL","contextChange","pop","currentRenderTargetData","isTexture","get","_initRenderTarget","copyToTexture","sourceRenderSurfaceTexture","destinationTexture","originSrc","originDest","Math","min","ensureDepthStencil","key","CanvasSource","test","getCanvasTexture","TextureSource","once","destroyGpuRenderTarget","set","initGpuRenderTarget","UboSystem","_syncFunctionHash","_adaptor","_systemCheck","Error","ensureUniformGroup","uniformGroup","uniformData","getUniformGroupData","data","layout","usage","UNIFORM","COPY_DST","_signature","_initUniformGroup","uniformGroupSignature","elements","keys","uniformStructures","createUboElements","syncFunction","_generateUboSync","uboElements","generateUboSync","syncUniformGroup","uniformGroupData","uniforms","updateUniformGroup","isStatic","_dirtyId","synced","update","createUboSyncFunction","parserCode","arrayGenerationFunction","singleSettersMap","funcFragments","prev","uboElement","parsed","ubo","template","type","fragmentSrc","join","Function","loopMatrix","col","row","uboSyncFunctionsSTD40","f32","i32","uboSyncFunctionsWGSL","uniformParsers","value","uniform","red","CustomRenderPipe","addRenderable","container","instructionSet","renderPipes","batch","break","add","execute","isRenderable","render","executeInstructions","renderGroup","instructions","instructionSize","instruction","renderPipeId","extension","WebGLPipes","WebGPUPipes","CanvasPipes","RenderGroupPipe","addRenderGroup","globalUniforms","worldTransformMatrix","worldTransform","worldColor","worldColorAlpha","buildInstructions","root","reset","buildStart","blendMode","colorMask","sortableChildren","sortChildren","collectAllRenderablesAdvanced","buildEnd","collectAllRenderables","rendererPipes","globalDisplayStatus","includeInBuild","isSimple","setBlendMode","groupBlendMode","didViewUpdate","children","collectAllRenderablesSimple","effects","effect","pipe","collectRenderGroups","out","renderGroupChildren","WHITE_BGR","mixColors","localBGRColor","parentBGRColor","color1","color2","ratio","r1","g1","b1","tempContainer","Container","updateRenderGroupTransforms","updateChildRenderGroups","worldAlpha","renderGroupParent","appendFrom","relativeGroupTransform","groupColor","groupAlpha","localTransform","localColor","localAlpha","updateRenderGroupTransform","childrenToUpdate","updateTick","childrenAtDepth","list","index","child","parentRenderGroup","updateTransformAndChildren","updateFlags","updateLocalTransform","parent","_updateFlags","updateColorBlendVisibility","structureDidChange","updateRenderable","groupColorAlpha","localBlendMode","localDisplayStatus","validateRenderables","childrenRenderablesToUpdate","rebuildRequired","validateRenderable","tempMatrix","RenderGroupSystem","transform","isRenderGroup","renderGroups","originalLocalTransform","runOnRender","updateRenderables","upload","uniformBatch","renderEnd","WebGLSystem","WebGPUSystem","CanvasSystem","SpritePipe","_gpuSpriteHash","sprite","_instructionSet","gpuSprite","_getGpuSprite","_didSpriteUpdate","_updateBatchableSprite","addToBatch","batcher","updateElement","_texture","_source","checkAndUpdateTexture","destroyRenderable","batchableSprite","return","bounds","_initGPUSprite","BatchableSprite","renderable","roundPixels","_roundPixels","BatcherPipe","state","State","for2d","_batches","_geometries","init","Batcher","BatchGeometry","_activeBatch","_activeGeometry","begin","batchableObject","activeBatch","finish","indexBuffer","setDataWithSize","indexSize","attributeBuffer","float32View","attributeSize","dirty","action","_Filter","Shader","options","enabled","_state","padding","blendRequired","addResource","apply","filterManager","input","output","clearMode","applyFilter","from","gpu","gl","rest","gpuProgram","glProgram","GpuProgram","GlProgram","Filter","MaskFilter","textureMatrix","TextureMatrix","filterUniforms","UniformGroup","uFilterMatrix","uMaskClamp","uClampFrame","uAlpha","entryPoint","resources","uMaskTexture","_textureMatrix","calculateSpriteMatrix","prepend","mapCoord","tempBounds","Bounds","AlphaMaskEffect","FilterEffect","filters","Sprite","EMPTY","AlphaMaskPipe","_activeMaskStage","mask","maskedContainer","canBundle","renderMaskToTexture","maskContainer","_maskedContainer","renderMask","filterEffect","measurable","getGlobalBounds","ceil","filterTexture","TexturePool","getOptimalTexture","minX","minY","maskData","filter","returnTexture","ColorMaskPipe","_colorStack","_colorStackIndex","_currentColor","_container","colorStack","currentColor","_mask","setMask","StencilMaskPipe","_maskStackHash","_maskHash","WeakMap","_a","has","instructionsStart","instructionsLength","renderTargetUid","maskStackIndex","setStencilMode","STENCIL","_BackgroundSystem","clearBeforeRender","_backgroundColor","Color","color","alpha","background","backgroundColor","backgroundAlpha","setAlpha","setValue","colorRgba","toArray","priority","BackgroundSystem","BLEND_MODE_FILTERS","handle","BlendMode","ref","BlendModePipe","_isAdvanced","_filterHash","_activeBlendMode","_endAdvancedBlendMode","_beginAdvancedBlendMode","_renderableList","warn","renderables","imageTypes","png","jpg","webp","_ExtractSystem","_normalizeOptions","defaults","image","Image","src","base64","defaultImageOptions","quality","canvas","toBlob","Promise","resolve","reject","blob","reader","FileReader","onload","result","onerror","readAsDataURL","toDataURL","convertToBlob","generateCanvas","textureGenerator","generateTexture","pixels","pixelInfo","getPixels","download","link","createElement","filename","href","appendChild","click","removeChild","log","console","style","ExtractSystem","RenderTexture","tempRect","noColor","GenerateTextureSystem","textureSourceOptions","view","Array","isArray","shared","region","copyTo","getLocalBounds","rectangle","max","translate","GlobalUniformSystem","_stackIndex","_globalUniformDataStack","_uniformsPool","_activeUniforms","_bindGroupPool","_activeBindGroups","currentGlobalUniformData","projectionData","Point","globalUniformData","bindGroup","_createUniforms","uProjectionMatrix","uResolution","uWorldTransformMatrix","uWorldColorAlpha","getUniformBindGroup","BindGroup","setResource","_currentGlobalUniformData","WEBGL","saidHello","VERSION","HelloSystem","hello","context","webGLVersion","getNavigator","userAgent","toLowerCase","indexOf","args","sayHello","_TextureGCSystem","count","checkCount","checkCountMax","textureGCCheckCountMax","maxIdle","textureGCAMaxIdle","active","textureGCActive","postrender","run","managedTextures","autoGarbageCollect","unload","TextureGCSystem","_ViewSystem","deprecation","screen","createCanvas","transparent","multiView","autoDensity","desiredScreenWidth","desiredScreenHeight","removeView","parentNode","SharedSystems","SharedRenderPipes","canvasCache","onDestroy","delete"],"sourceRoot":""}